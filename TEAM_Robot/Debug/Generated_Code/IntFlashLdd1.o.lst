   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"IntFlashLdd1.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.section	.rodata.SafeRoutine,"a",%progbits
  21              		.align	2
  24              	SafeRoutine:
  25 0000 07B4     		.short	-19449
  26 0002 0949     		.short	18697
  27 0004 8020     		.short	8320
  28 0006 0870     		.short	28680
  29 0008 0878     		.short	30728
  30 000a 0006     		.short	1536
  31 000c FCD5     		.short	-10756
  32 000e 0749     		.short	18695
  33 0010 0A68     		.short	26634
  34 0012 0020     		.short	8192
  35 0014 0860     		.short	24584
  36 0016 4FF4     		.short	-2993
  37 0018 7800     		.short	120
  38 001a 0860     		.short	24584
  39 001c 0A60     		.short	24586
  40 001e 4A68     		.short	26698
  41 0020 4860     		.short	24648
  42 0022 4A60     		.short	24650
  43 0024 07BC     		.short	-17401
  44 0026 7047     		.short	18288
  45 0028 0000     		.short	0
  46 002a 0240     		.short	16386
  47 002c 04F0     		.short	-4092
  48 002e 0140     		.short	16385
  49              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  50              		.align	2
  53              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  54 0000 00000000 		.space	24
  54      00000000 
  54      00000000 
  54      00000000 
  54      00000000 
  55              		.section	.text.IntFlashLdd1_Init,"ax",%progbits
  56              		.align	2
  57              		.global	IntFlashLdd1_Init
  58              		.thumb
  59              		.thumb_func
  61              	IntFlashLdd1_Init:
  62              	.LFB0:
  63              		.file 1 "../Generated_Code/IntFlashLdd1.c"
   1:../Generated_Code/IntFlashLdd1.c **** /* ###################################################################
   2:../Generated_Code/IntFlashLdd1.c **** **     This component module is generated by Processor Expert. Do not modify it.
   3:../Generated_Code/IntFlashLdd1.c **** **     Filename    : IntFlashLdd1.c
   4:../Generated_Code/IntFlashLdd1.c **** **     Project     : TEAM_Robot
   5:../Generated_Code/IntFlashLdd1.c **** **     Processor   : MK22FX512VLK12
   6:../Generated_Code/IntFlashLdd1.c **** **     Component   : FLASH_LDD
   7:../Generated_Code/IntFlashLdd1.c **** **     Version     : Component 01.106, Driver 01.15, CPU db: 3.00.000
   8:../Generated_Code/IntFlashLdd1.c **** **     Repository  : Kinetis
   9:../Generated_Code/IntFlashLdd1.c **** **     Compiler    : GNU C Compiler
  10:../Generated_Code/IntFlashLdd1.c **** **     Date/Time   : 2018-09-28, 15:03, # CodeGen: 0
  11:../Generated_Code/IntFlashLdd1.c **** **     Abstract    :
  12:../Generated_Code/IntFlashLdd1.c **** **          This embedded component implements an access to an on-chip flash memory.
  13:../Generated_Code/IntFlashLdd1.c **** **          Using this component the flash memory could be written to, erased,
  14:../Generated_Code/IntFlashLdd1.c **** **          read from. Some other services would be provided, if they are supported
  15:../Generated_Code/IntFlashLdd1.c **** **          by hardware, e.g. changes of the flash memory protection state.
  16:../Generated_Code/IntFlashLdd1.c **** **     Settings    :
  17:../Generated_Code/IntFlashLdd1.c **** **          Component name                                 : IntFlashLdd1
  18:../Generated_Code/IntFlashLdd1.c **** **          Device                                         : FTFE
  19:../Generated_Code/IntFlashLdd1.c **** **          Use user memory areas                          : no
  20:../Generated_Code/IntFlashLdd1.c **** **          Interrupt service                              : Disabled
  21:../Generated_Code/IntFlashLdd1.c **** **            Write batch size                             : Minimal
  22:../Generated_Code/IntFlashLdd1.c **** **            Erase batch size                             : Minimal
  23:../Generated_Code/IntFlashLdd1.c **** **            Read batch size                              : Unlimited
  24:../Generated_Code/IntFlashLdd1.c **** **          Safe launch and wait                           : yes
  25:../Generated_Code/IntFlashLdd1.c **** **            Safe routine location                        : On stack
  26:../Generated_Code/IntFlashLdd1.c **** **            Interruptable wait loop                      : no
  27:../Generated_Code/IntFlashLdd1.c **** **          Initialization                                 : 
  28:../Generated_Code/IntFlashLdd1.c **** **            Enabled in init. code                        : yes
  29:../Generated_Code/IntFlashLdd1.c **** **            Auto initialization                          : no
  30:../Generated_Code/IntFlashLdd1.c **** **            Event mask                                   : 
  31:../Generated_Code/IntFlashLdd1.c **** **              OnOperationComplete                        : Enabled
  32:../Generated_Code/IntFlashLdd1.c **** **              OnError                                    : Enabled
  33:../Generated_Code/IntFlashLdd1.c **** **            CPU clock/configuration selection            : 
  34:../Generated_Code/IntFlashLdd1.c **** **              Clock configuration 0                      : This component enabled
  35:../Generated_Code/IntFlashLdd1.c **** **              Clock configuration 1                      : This component disabled
  36:../Generated_Code/IntFlashLdd1.c **** **              Clock configuration 2                      : This component disabled
  37:../Generated_Code/IntFlashLdd1.c **** **              Clock configuration 3                      : This component disabled
  38:../Generated_Code/IntFlashLdd1.c **** **              Clock configuration 4                      : This component disabled
  39:../Generated_Code/IntFlashLdd1.c **** **              Clock configuration 5                      : This component disabled
  40:../Generated_Code/IntFlashLdd1.c **** **              Clock configuration 6                      : This component disabled
  41:../Generated_Code/IntFlashLdd1.c **** **              Clock configuration 7                      : This component disabled
  42:../Generated_Code/IntFlashLdd1.c **** **     Contents    :
  43:../Generated_Code/IntFlashLdd1.c **** **         Init               - LDD_TDeviceData* IntFlashLdd1_Init(LDD_TUserData *UserDataPtr);
  44:../Generated_Code/IntFlashLdd1.c **** **         Read               - LDD_TError IntFlashLdd1_Read(LDD_TDeviceData *DeviceDataPtr,...
  45:../Generated_Code/IntFlashLdd1.c **** **         Write              - LDD_TError IntFlashLdd1_Write(LDD_TDeviceData *DeviceDataPtr, LDD_T
  46:../Generated_Code/IntFlashLdd1.c **** **         Erase              - LDD_TError IntFlashLdd1_Erase(LDD_TDeviceData *DeviceDataPtr,...
  47:../Generated_Code/IntFlashLdd1.c **** **         GetOperationStatus - LDD_FLASH_TOperationStatus IntFlashLdd1_GetOperationStatus(LDD_TDev
  48:../Generated_Code/IntFlashLdd1.c **** **         GetError           - void IntFlashLdd1_GetError(LDD_TDeviceData *DeviceDataPtr,...
  49:../Generated_Code/IntFlashLdd1.c **** **         Main               - void IntFlashLdd1_Main(LDD_TDeviceData *DeviceDataPtr);
  50:../Generated_Code/IntFlashLdd1.c **** **         GetDriverState     - LDD_TDriverState IntFlashLdd1_GetDriverState(LDD_TDeviceData *Devic
  51:../Generated_Code/IntFlashLdd1.c **** **
  52:../Generated_Code/IntFlashLdd1.c **** **     Copyright : 1997 - 2015 Freescale Semiconductor, Inc. 
  53:../Generated_Code/IntFlashLdd1.c **** **     All Rights Reserved.
  54:../Generated_Code/IntFlashLdd1.c **** **     
  55:../Generated_Code/IntFlashLdd1.c **** **     Redistribution and use in source and binary forms, with or without modification,
  56:../Generated_Code/IntFlashLdd1.c **** **     are permitted provided that the following conditions are met:
  57:../Generated_Code/IntFlashLdd1.c **** **     
  58:../Generated_Code/IntFlashLdd1.c **** **     o Redistributions of source code must retain the above copyright notice, this list
  59:../Generated_Code/IntFlashLdd1.c **** **       of conditions and the following disclaimer.
  60:../Generated_Code/IntFlashLdd1.c **** **     
  61:../Generated_Code/IntFlashLdd1.c **** **     o Redistributions in binary form must reproduce the above copyright notice, this
  62:../Generated_Code/IntFlashLdd1.c **** **       list of conditions and the following disclaimer in the documentation and/or
  63:../Generated_Code/IntFlashLdd1.c **** **       other materials provided with the distribution.
  64:../Generated_Code/IntFlashLdd1.c **** **     
  65:../Generated_Code/IntFlashLdd1.c **** **     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
  66:../Generated_Code/IntFlashLdd1.c **** **       contributors may be used to endorse or promote products derived from this
  67:../Generated_Code/IntFlashLdd1.c **** **       software without specific prior written permission.
  68:../Generated_Code/IntFlashLdd1.c **** **     
  69:../Generated_Code/IntFlashLdd1.c **** **     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  70:../Generated_Code/IntFlashLdd1.c **** **     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  71:../Generated_Code/IntFlashLdd1.c **** **     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  72:../Generated_Code/IntFlashLdd1.c **** **     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  73:../Generated_Code/IntFlashLdd1.c **** **     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  74:../Generated_Code/IntFlashLdd1.c **** **     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  75:../Generated_Code/IntFlashLdd1.c **** **     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  76:../Generated_Code/IntFlashLdd1.c **** **     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  77:../Generated_Code/IntFlashLdd1.c **** **     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  78:../Generated_Code/IntFlashLdd1.c **** **     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  79:../Generated_Code/IntFlashLdd1.c **** **     
  80:../Generated_Code/IntFlashLdd1.c **** **     http: www.freescale.com
  81:../Generated_Code/IntFlashLdd1.c **** **     mail: support@freescale.com
  82:../Generated_Code/IntFlashLdd1.c **** ** ###################################################################*/
  83:../Generated_Code/IntFlashLdd1.c **** /*!
  84:../Generated_Code/IntFlashLdd1.c **** ** @file IntFlashLdd1.c
  85:../Generated_Code/IntFlashLdd1.c **** ** @version 01.15
  86:../Generated_Code/IntFlashLdd1.c **** ** @brief
  87:../Generated_Code/IntFlashLdd1.c **** **          This embedded component implements an access to an on-chip flash memory.
  88:../Generated_Code/IntFlashLdd1.c **** **          Using this component the flash memory could be written to, erased,
  89:../Generated_Code/IntFlashLdd1.c **** **          read from. Some other services would be provided, if they are supported
  90:../Generated_Code/IntFlashLdd1.c **** **          by hardware, e.g. changes of the flash memory protection state.
  91:../Generated_Code/IntFlashLdd1.c **** */         
  92:../Generated_Code/IntFlashLdd1.c **** /*!
  93:../Generated_Code/IntFlashLdd1.c **** **  @addtogroup IntFlashLdd1_module IntFlashLdd1 module documentation
  94:../Generated_Code/IntFlashLdd1.c **** **  @{
  95:../Generated_Code/IntFlashLdd1.c **** */         
  96:../Generated_Code/IntFlashLdd1.c **** 
  97:../Generated_Code/IntFlashLdd1.c **** /* MODULE IntFlashLdd1. */
  98:../Generated_Code/IntFlashLdd1.c **** 
  99:../Generated_Code/IntFlashLdd1.c **** #include "IFsh1.h"
 100:../Generated_Code/IntFlashLdd1.c **** #include "IntFlashLdd1.h"
 101:../Generated_Code/IntFlashLdd1.c **** /* {Default RTOS Adapter} No RTOS includes */
 102:../Generated_Code/IntFlashLdd1.c **** 
 103:../Generated_Code/IntFlashLdd1.c **** #ifdef __cplusplus
 104:../Generated_Code/IntFlashLdd1.c **** extern "C" {
 105:../Generated_Code/IntFlashLdd1.c **** #endif
 106:../Generated_Code/IntFlashLdd1.c **** 
 107:../Generated_Code/IntFlashLdd1.c **** #define FTFE_FLEXNVM_START_ADDR          0x10000000U
 108:../Generated_Code/IntFlashLdd1.c **** /* bit 23 selects between pFLASH and FLEXNVM regions */
 109:../Generated_Code/IntFlashLdd1.c **** #define FTFE_FLEXNVM_CCOB_START_ADDR     0x00800000U
 110:../Generated_Code/IntFlashLdd1.c **** 
 111:../Generated_Code/IntFlashLdd1.c **** 
 112:../Generated_Code/IntFlashLdd1.c **** /* SafeRoutine() method prototype */
 113:../Generated_Code/IntFlashLdd1.c **** typedef void (* LDD_FLASH_TSafeRoutinePtr)(void); 
 114:../Generated_Code/IntFlashLdd1.c **** 
 115:../Generated_Code/IntFlashLdd1.c **** /* Structure used to copy SafeRoutine() code from FLASH to RAM. */
 116:../Generated_Code/IntFlashLdd1.c **** typedef struct{
 117:../Generated_Code/IntFlashLdd1.c ****   uint16_t SafeRoutine[24];            /* Safe routine code buffer */
 118:../Generated_Code/IntFlashLdd1.c **** } LDD_FLASH_TSafeRoutine;              /* Safe routine code buffer type */
 119:../Generated_Code/IntFlashLdd1.c **** 
 120:../Generated_Code/IntFlashLdd1.c **** /* Structure is used to allocate space for SafeRoutine() in the device data structure. */
 121:../Generated_Code/IntFlashLdd1.c **** /* Note: Code of SafeRoutine() must be placed on 4 bytes aligned address = 3 bytes of padding are a
 122:../Generated_Code/IntFlashLdd1.c **** typedef struct{
 123:../Generated_Code/IntFlashLdd1.c ****   uint16_t SafeRoutine[24];            /* Safe routine code buffer */
 124:../Generated_Code/IntFlashLdd1.c ****   uint8_t Padding[3];                  /* Padding */  
 125:../Generated_Code/IntFlashLdd1.c **** } LDD_FLASH_TSafeRoutineWithPadding;   /* Safe routine code buffer type */
 126:../Generated_Code/IntFlashLdd1.c **** 
 127:../Generated_Code/IntFlashLdd1.c **** /*
 128:../Generated_Code/IntFlashLdd1.c **** Safe launch and wait routine code. This code launch a command, waits for command
 129:../Generated_Code/IntFlashLdd1.c **** completion or command violation and then invalidates flash cache(s) and buffers.
 130:../Generated_Code/IntFlashLdd1.c **** Routine is written as array of words to be constant size and compiler independent.
 131:../Generated_Code/IntFlashLdd1.c **** C language implementation for Kinetis K could look like:
 132:../Generated_Code/IntFlashLdd1.c **** 
 133:../Generated_Code/IntFlashLdd1.c **** void SafeRoutine(void) {
 134:../Generated_Code/IntFlashLdd1.c ****   uint32_t CacheSetting;
 135:../Generated_Code/IntFlashLdd1.c ****   
 136:../Generated_Code/IntFlashLdd1.c ****   FTFE_PDD_LaunchCommand(FTFE_BASE_PTR);
 137:../Generated_Code/IntFlashLdd1.c ****   while ((FTFE_PDD_GetFlags(FTFE_BASE_PTR) & FTFE_PDD_COMMAND_COMPLETE) == 0U ) {};
 138:../Generated_Code/IntFlashLdd1.c ****   
 139:../Generated_Code/IntFlashLdd1.c ****   CacheSetting = FMC_PDD_GetFlashBankCacheAndBuffersSetting(FMC_BASE_PTR);
 140:../Generated_Code/IntFlashLdd1.c ****   FMC_PDD_DisableFlashBankCacheAndBuffers(FMC_BASE_PTR);
 141:../Generated_Code/IntFlashLdd1.c ****   FMC_PDD_InvalideteFlashCaheAndBuffers(FMC_BASE_PTR);
 142:../Generated_Code/IntFlashLdd1.c ****   FMC_PDD_SetFlashBankCacheAndBuffers(FMC_BASE_PTR, CacheSetting);
 143:../Generated_Code/IntFlashLdd1.c **** }
 144:../Generated_Code/IntFlashLdd1.c **** 
 145:../Generated_Code/IntFlashLdd1.c **** */
 146:../Generated_Code/IntFlashLdd1.c **** static const uint16_t SafeRoutine[24] = {
 147:../Generated_Code/IntFlashLdd1.c ****   0xb407,          /*  push  {r0, r1, r2}                                    */
 148:../Generated_Code/IntFlashLdd1.c ****   0x4909,          /*  ldr   r1, FTFE_FSTAT_RegAddress                       */  
 149:../Generated_Code/IntFlashLdd1.c ****   0x2080,          /*  movs  r0, #0x80                                       */
 150:../Generated_Code/IntFlashLdd1.c ****   0x7008,          /*  strb  r0, [r1, #0]                                    */
 151:../Generated_Code/IntFlashLdd1.c ****   /* while(!FTFE_PDD_GetCmdCompleteFlag(FTFE_PDD_BASE_PTR)){}                */  
 152:../Generated_Code/IntFlashLdd1.c ****                    /* <LoadFlags>:                                           */
 153:../Generated_Code/IntFlashLdd1.c ****   0x7808,          /*  ldrb  r0, [r1, #0]                                    */
 154:../Generated_Code/IntFlashLdd1.c ****   0x0600,          /*  lsls  r0, r0, #24                                     */
 155:../Generated_Code/IntFlashLdd1.c ****   0xd5fc,          /*  bpl.n a <LoadFlags>                                   */
 156:../Generated_Code/IntFlashLdd1.c ****   /* r2 =  FMC_PFB0CR                                                        */ 
 157:../Generated_Code/IntFlashLdd1.c ****   0x4907,          /*  ldr   r1, FMC_PFB0CR_RegAddress                       */
 158:../Generated_Code/IntFlashLdd1.c ****   0x680a,          /*  ldr   r2, [r1, #0]                                    */
 159:../Generated_Code/IntFlashLdd1.c ****   /* FMC_PFB0CR =  0; - Disable cache and buffers                            */ 
 160:../Generated_Code/IntFlashLdd1.c ****   0x2000,          /*  movs  r0, #0x00                                       */
 161:../Generated_Code/IntFlashLdd1.c ****   0x6008,          /*  str   r0, [r1, #0]                                    */
 162:../Generated_Code/IntFlashLdd1.c ****   /* FMC_PFB0CR = 0xf80000; - Invalidate all cache ways                      */ 
 163:../Generated_Code/IntFlashLdd1.c ****   0xf44f, 0x0078,  /*  mov.w r0, #0xf80000                                   */
 164:../Generated_Code/IntFlashLdd1.c ****   0x6008,          /*  str   r0, [r1, #0]                                    */
 165:../Generated_Code/IntFlashLdd1.c ****   /* FMC_PFB0CR =  r2  revert cache settings                                 */ 
 166:../Generated_Code/IntFlashLdd1.c ****   0x600a,          /*  str   r2, [r1, #0]                                    */
 167:../Generated_Code/IntFlashLdd1.c ****   /* r2 =  FMC_PFB1CR                                                        */ 
 168:../Generated_Code/IntFlashLdd1.c ****   0x684a,          /*  ldr   r2, [r1, #4]                                    */
 169:../Generated_Code/IntFlashLdd1.c ****   /* FMC_PFB1CR =  0; - Disable cache and buffers                            */ 
 170:../Generated_Code/IntFlashLdd1.c ****   0x6048,          /*  str   r0, [r1, #4]                                    */
 171:../Generated_Code/IntFlashLdd1.c ****   /* FMC_PFB1CR =  r2  revert cache settings                                 */ 
 172:../Generated_Code/IntFlashLdd1.c ****   0x604a,          /*  str   r2, [r1, #4]                                    */
 173:../Generated_Code/IntFlashLdd1.c ****   0xbc07,          /*  pop   {r0, r1, r2}                                    */
 174:../Generated_Code/IntFlashLdd1.c ****   0x4770,          /*  bx    lr                                              */
 175:../Generated_Code/IntFlashLdd1.c ****   /* FTFE_FSTAT_RegAddress:                                                  */
 176:../Generated_Code/IntFlashLdd1.c ****   (uint16_t)(((uint32_t)&FTFE_FSTAT)>>0 & 0xFFFF),
 177:../Generated_Code/IntFlashLdd1.c ****   (uint16_t)(((uint32_t)&FTFE_FSTAT)>>16 & 0xFFFF),
 178:../Generated_Code/IntFlashLdd1.c ****   /* FMC_PFB0CR_RegAddress:                                                  */
 179:../Generated_Code/IntFlashLdd1.c ****   (uint16_t)(((uint32_t)&FMC_PFB0CR)>>0 & 0xFFFF),
 180:../Generated_Code/IntFlashLdd1.c ****   (uint16_t)(((uint32_t)&FMC_PFB0CR)>>16 & 0xFFFF)
 181:../Generated_Code/IntFlashLdd1.c **** };
 182:../Generated_Code/IntFlashLdd1.c **** 
 183:../Generated_Code/IntFlashLdd1.c **** typedef struct {
 184:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TOperationType          CurrentOperation; /* Current operation type */
 185:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TOperationStatus        CurrentOperationStatus; /* Current operation status */
 186:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TCommand                CurrentCommand; /* Last flash device command */
 187:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TErrorFlags             CurrentErrorFlags; /* Current error flags */
 188:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TDataSize               CurrentDataSize; /* Data size of the current operation step */
 189:../Generated_Code/IntFlashLdd1.c ****   uint32_t                          DataCounter; /* Counter of data to be proceeded in the current 
 190:../Generated_Code/IntFlashLdd1.c ****   uint8_t                          *CurrentDataPtr; /* Pointer to the source/destination data for t
 191:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TAddress                CurrentFlashAddress; /* Address of destination/source in the fl
 192:../Generated_Code/IntFlashLdd1.c ****   LDD_TUserData                    *UserDataPtr; /* Pointer to user data */
 193:../Generated_Code/IntFlashLdd1.c **** } IntFlashLdd1_TDeviceData;
 194:../Generated_Code/IntFlashLdd1.c **** 
 195:../Generated_Code/IntFlashLdd1.c **** typedef IntFlashLdd1_TDeviceData *IntFlashLdd1_TDeviceDataPtr; /* Pointer to the device data struct
 196:../Generated_Code/IntFlashLdd1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 197:../Generated_Code/IntFlashLdd1.c **** static IntFlashLdd1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 198:../Generated_Code/IntFlashLdd1.c **** 
 199:../Generated_Code/IntFlashLdd1.c **** #define AVAILABLE_EVENTS_MASK (LDD_FLASH_ON_OPERATION_COMPLETE | LDD_FLASH_ON_ERROR)
 200:../Generated_Code/IntFlashLdd1.c **** 
 201:../Generated_Code/IntFlashLdd1.c **** /* Internal method prototypes */
 202:../Generated_Code/IntFlashLdd1.c **** static LDD_TError RangeCheck(LDD_FLASH_TAddress Address, LDD_FLASH_TDataSize Size);
 203:../Generated_Code/IntFlashLdd1.c **** static void SafeRoutineCaller(void);
 204:../Generated_Code/IntFlashLdd1.c **** 
 205:../Generated_Code/IntFlashLdd1.c **** /*
 206:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 207:../Generated_Code/IntFlashLdd1.c **** **     Method      :  IntFlashLdd1_Init (component FLASH_LDD)
 208:../Generated_Code/IntFlashLdd1.c **** */
 209:../Generated_Code/IntFlashLdd1.c **** /*!
 210:../Generated_Code/IntFlashLdd1.c **** **     @brief
 211:../Generated_Code/IntFlashLdd1.c **** **         Initializes the device. Allocates memory for the device data
 212:../Generated_Code/IntFlashLdd1.c **** **         structure, allocates interrupt vectors and sets interrupt
 213:../Generated_Code/IntFlashLdd1.c **** **         priority, sets pin routing, sets timing, etc. If the "Enable
 214:../Generated_Code/IntFlashLdd1.c **** **         in init. code" property is set to "yes" ([Enabled in init.
 215:../Generated_Code/IntFlashLdd1.c **** **         code]) value then the device is also enabled(see the
 216:../Generated_Code/IntFlashLdd1.c **** **         description of the Enable() method). In this case the
 217:../Generated_Code/IntFlashLdd1.c **** **         Enable() method is not necessary and needn't to be generated.
 218:../Generated_Code/IntFlashLdd1.c **** **         This method can be called only once. Before the second call
 219:../Generated_Code/IntFlashLdd1.c **** **         of Init() the Deinit() must be called first.
 220:../Generated_Code/IntFlashLdd1.c **** **     @param
 221:../Generated_Code/IntFlashLdd1.c **** **         UserDataPtr     - Pointer to the user or
 222:../Generated_Code/IntFlashLdd1.c **** **                           RTOS specific data. This pointer will be
 223:../Generated_Code/IntFlashLdd1.c **** **                           passed as an event or callback parameter.
 224:../Generated_Code/IntFlashLdd1.c **** **     @return
 225:../Generated_Code/IntFlashLdd1.c **** **                         - Device data structure pointer.
 226:../Generated_Code/IntFlashLdd1.c **** */
 227:../Generated_Code/IntFlashLdd1.c **** /* ===================================================================*/
 228:../Generated_Code/IntFlashLdd1.c **** LDD_TDeviceData* IntFlashLdd1_Init(LDD_TUserData *UserDataPtr)
 229:../Generated_Code/IntFlashLdd1.c **** {
  64              		.loc 1 229 0
  65              		.cfi_startproc
  66              		@ args = 0, pretend = 0, frame = 16
  67              		@ frame_needed = 1, uses_anonymous_args = 0
  68              		@ link register save eliminated.
  69 0000 80B4     		push	{r7}
  70              		.cfi_def_cfa_offset 4
  71              		.cfi_offset 7, -4
  72 0002 85B0     		sub	sp, sp, #20
  73              		.cfi_def_cfa_offset 24
  74 0004 00AF     		add	r7, sp, #0
  75              		.cfi_def_cfa_register 7
  76 0006 7860     		str	r0, [r7, #4]
 230:../Generated_Code/IntFlashLdd1.c ****   IntFlashLdd1_TDeviceDataPtr DeviceDataPrv;
 231:../Generated_Code/IntFlashLdd1.c **** 
 232:../Generated_Code/IntFlashLdd1.c ****   /* Allocate LDD device structure */
 233:../Generated_Code/IntFlashLdd1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 234:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  77              		.loc 1 234 0
  78 0008 134B     		ldr	r3, .L3
  79 000a FB60     		str	r3, [r7, #12]
 235:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentOperationStatus = LDD_FLASH_IDLE; /* Initialization of the Current operatio
  80              		.loc 1 235 0
  81 000c FB68     		ldr	r3, [r7, #12]
  82 000e 0222     		movs	r2, #2
  83 0010 5A70     		strb	r2, [r3, #1]
 236:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentOperation = LDD_FLASH_NO_OPERATION; /* Initialization of the Current operat
  84              		.loc 1 236 0
  85 0012 FB68     		ldr	r3, [r7, #12]
  86 0014 0022     		movs	r2, #0
  87 0016 1A70     		strb	r2, [r3]
 237:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentErrorFlags = 0U; /* Initialization of the Current error flags item */
  88              		.loc 1 237 0
  89 0018 FB68     		ldr	r3, [r7, #12]
  90 001a 0022     		movs	r2, #0
  91 001c DA70     		strb	r2, [r3, #3]
 238:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentDataPtr = NULL; /* Initialization of the Current data pointer item */
  92              		.loc 1 238 0
  93 001e FB68     		ldr	r3, [r7, #12]
  94 0020 0022     		movs	r2, #0
  95 0022 DA60     		str	r2, [r3, #12]
 239:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store a pointer to the User data structure */
  96              		.loc 1 239 0
  97 0024 FB68     		ldr	r3, [r7, #12]
  98 0026 7A68     		ldr	r2, [r7, #4]
  99 0028 5A61     		str	r2, [r3, #20]
 240:../Generated_Code/IntFlashLdd1.c ****   /* SIM_SCGC6: FTF=1 */
 241:../Generated_Code/IntFlashLdd1.c ****   SIM_SCGC6 |= SIM_SCGC6_FTF_MASK;
 100              		.loc 1 241 0
 101 002a 0C49     		ldr	r1, .L3+4
 102 002c 0B4B     		ldr	r3, .L3+4
 103 002e 03F58153 		add	r3, r3, #4128
 104 0032 1C33     		adds	r3, r3, #28
 105 0034 1B68     		ldr	r3, [r3]
 106 0036 43F00102 		orr	r2, r3, #1
 107 003a 01F58153 		add	r3, r1, #4128
 108 003e 1C33     		adds	r3, r3, #28
 109 0040 1A60     		str	r2, [r3]
 242:../Generated_Code/IntFlashLdd1.c ****   /* Registration of the device structure */
 243:../Generated_Code/IntFlashLdd1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_IntFlashLdd1_ID,DeviceDataPrv);
 110              		.loc 1 243 0
 111 0042 074B     		ldr	r3, .L3+8
 112 0044 FA68     		ldr	r2, [r7, #12]
 113 0046 DA65     		str	r2, [r3, #92]
 244:../Generated_Code/IntFlashLdd1.c ****   return DeviceDataPrv;
 114              		.loc 1 244 0
 115 0048 FB68     		ldr	r3, [r7, #12]
 245:../Generated_Code/IntFlashLdd1.c **** }
 116              		.loc 1 245 0
 117 004a 1846     		mov	r0, r3
 118 004c 1437     		adds	r7, r7, #20
 119 004e BD46     		mov	sp, r7
 120              		@ sp needed
 121 0050 5DF8047B 		ldr	r7, [sp], #4
 122 0054 7047     		bx	lr
 123              	.L4:
 124 0056 00BF     		.align	2
 125              	.L3:
 126 0058 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 127 005c 00700440 		.word	1074032640
 128 0060 00000000 		.word	PE_LDD_DeviceDataList
 129              		.cfi_endproc
 130              	.LFE0:
 132              		.section	.text.IntFlashLdd1_Write,"ax",%progbits
 133              		.align	2
 134              		.global	IntFlashLdd1_Write
 135              		.thumb
 136              		.thumb_func
 138              	IntFlashLdd1_Write:
 139              	.LFB1:
 246:../Generated_Code/IntFlashLdd1.c **** 
 247:../Generated_Code/IntFlashLdd1.c **** /*
 248:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 249:../Generated_Code/IntFlashLdd1.c **** **     Method      :  IntFlashLdd1_Write (component FLASH_LDD)
 250:../Generated_Code/IntFlashLdd1.c **** */
 251:../Generated_Code/IntFlashLdd1.c **** /*!
 252:../Generated_Code/IntFlashLdd1.c **** **     @brief
 253:../Generated_Code/IntFlashLdd1.c **** **         This method sets up a flash memory write operation. The
 254:../Generated_Code/IntFlashLdd1.c **** **         operation itself is performing by defined batches (property
 255:../Generated_Code/IntFlashLdd1.c **** **         [Write batch size]) by periodical calling the component’s
 256:../Generated_Code/IntFlashLdd1.c **** **         Main method in the user application (higher level OS service)
 257:../Generated_Code/IntFlashLdd1.c **** **         or by the component’s ISR, if an component’s interrupt
 258:../Generated_Code/IntFlashLdd1.c **** **         service is enabled.
 259:../Generated_Code/IntFlashLdd1.c **** **     @param
 260:../Generated_Code/IntFlashLdd1.c **** **         DeviceDataPtr   - Device data structure
 261:../Generated_Code/IntFlashLdd1.c **** **                           pointer returned by [Init] method.
 262:../Generated_Code/IntFlashLdd1.c **** **     @param
 263:../Generated_Code/IntFlashLdd1.c **** **         FromPtr         - Pointer to data to be written to
 264:../Generated_Code/IntFlashLdd1.c **** **                           the flash memory.
 265:../Generated_Code/IntFlashLdd1.c **** **     @param
 266:../Generated_Code/IntFlashLdd1.c **** **         ToAddress       - Address to the flash memory
 267:../Generated_Code/IntFlashLdd1.c **** **                           the input data would be written to.
 268:../Generated_Code/IntFlashLdd1.c **** **     @param
 269:../Generated_Code/IntFlashLdd1.c **** **         Size            - Size of the input data (in bytes) to be
 270:../Generated_Code/IntFlashLdd1.c **** **                           written to the flash memory.
 271:../Generated_Code/IntFlashLdd1.c **** **     @return
 272:../Generated_Code/IntFlashLdd1.c **** **                         - Error code
 273:../Generated_Code/IntFlashLdd1.c **** **                           ERR_OK - OK
 274:../Generated_Code/IntFlashLdd1.c **** **                           ERR_DISABLED - Component is disabled
 275:../Generated_Code/IntFlashLdd1.c **** **                           ERR_SPEED - This device does not work in
 276:../Generated_Code/IntFlashLdd1.c **** **                           the active clock configuration
 277:../Generated_Code/IntFlashLdd1.c **** **                           ERR_BUSY - Some flash memory operation is
 278:../Generated_Code/IntFlashLdd1.c **** **                           already in progress 
 279:../Generated_Code/IntFlashLdd1.c **** **                           ERR_PARAM_ADDRESS - Desired flash memory
 280:../Generated_Code/IntFlashLdd1.c **** **                           area is out of allowed range
 281:../Generated_Code/IntFlashLdd1.c **** **                           ERR_NOTAVAIL - When Safe launch and wait
 282:../Generated_Code/IntFlashLdd1.c **** **                           mode is enabled (property Safe launch and
 283:../Generated_Code/IntFlashLdd1.c **** **                           wait) and safe routine location is defined
 284:../Generated_Code/IntFlashLdd1.c **** **                           in runtime (property Safe routine location)
 285:../Generated_Code/IntFlashLdd1.c **** **                           and the safe routine location has not been
 286:../Generated_Code/IntFlashLdd1.c **** **                           specified yet (the SetSafeRoutineLocation
 287:../Generated_Code/IntFlashLdd1.c **** **                           method has not been used to define the
 288:../Generated_Code/IntFlashLdd1.c **** **                           location the safe routine will be copied to).
 289:../Generated_Code/IntFlashLdd1.c **** */
 290:../Generated_Code/IntFlashLdd1.c **** /* ===================================================================*/
 291:../Generated_Code/IntFlashLdd1.c **** LDD_TError IntFlashLdd1_Write(LDD_TDeviceData *DeviceDataPtr, LDD_TData *FromPtr, LDD_FLASH_TAddres
 292:../Generated_Code/IntFlashLdd1.c **** {
 140              		.loc 1 292 0
 141              		.cfi_startproc
 142              		@ args = 0, pretend = 0, frame = 24
 143              		@ frame_needed = 1, uses_anonymous_args = 0
 144 0000 80B5     		push	{r7, lr}
 145              		.cfi_def_cfa_offset 8
 146              		.cfi_offset 7, -8
 147              		.cfi_offset 14, -4
 148 0002 86B0     		sub	sp, sp, #24
 149              		.cfi_def_cfa_offset 32
 150 0004 00AF     		add	r7, sp, #0
 151              		.cfi_def_cfa_register 7
 152 0006 F860     		str	r0, [r7, #12]
 153 0008 B960     		str	r1, [r7, #8]
 154 000a 7A60     		str	r2, [r7, #4]
 155 000c 3B60     		str	r3, [r7]
 293:../Generated_Code/IntFlashLdd1.c ****   IntFlashLdd1_TDeviceDataPtr DeviceDataPrv = (IntFlashLdd1_TDeviceDataPtr)DeviceDataPtr; /* Auxili
 156              		.loc 1 293 0
 157 000e FB68     		ldr	r3, [r7, #12]
 158 0010 7B61     		str	r3, [r7, #20]
 294:../Generated_Code/IntFlashLdd1.c **** 
 295:../Generated_Code/IntFlashLdd1.c ****   if (!(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_IDLE) && /* If some operation is already
 159              		.loc 1 295 0
 160 0012 7B69     		ldr	r3, [r7, #20]
 161 0014 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 162 0016 022B     		cmp	r3, #2
 163 0018 09D0     		beq	.L6
 296:../Generated_Code/IntFlashLdd1.c ****      !(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_STOP) && \
 164              		.loc 1 296 0 discriminator 1
 165 001a 7B69     		ldr	r3, [r7, #20]
 166 001c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 295:../Generated_Code/IntFlashLdd1.c ****   if (!(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_IDLE) && /* If some operation is already
 167              		.loc 1 295 0 discriminator 1
 168 001e 012B     		cmp	r3, #1
 169 0020 05D0     		beq	.L6
 297:../Generated_Code/IntFlashLdd1.c ****      !(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_FAILED)) {
 170              		.loc 1 297 0
 171 0022 7B69     		ldr	r3, [r7, #20]
 172 0024 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 296:../Generated_Code/IntFlashLdd1.c ****      !(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_STOP) && \
 173              		.loc 1 296 0
 174 0026 002B     		cmp	r3, #0
 175 0028 01D0     		beq	.L6
 298:../Generated_Code/IntFlashLdd1.c ****     return ERR_BUSY;
 176              		.loc 1 298 0
 177 002a 0823     		movs	r3, #8
 178 002c 1EE0     		b	.L7
 179              	.L6:
 299:../Generated_Code/IntFlashLdd1.c ****   }
 300:../Generated_Code/IntFlashLdd1.c ****   if (RangeCheck(ToAddress, Size) != (LDD_TError)ERR_OK) { /* Is the given flash memory area in the
 180              		.loc 1 300 0
 181 002e 7868     		ldr	r0, [r7, #4]
 182 0030 3968     		ldr	r1, [r7]
 183 0032 FFF7FEFF 		bl	RangeCheck
 184 0036 0346     		mov	r3, r0
 185 0038 002B     		cmp	r3, #0
 186 003a 01D0     		beq	.L8
 301:../Generated_Code/IntFlashLdd1.c ****     return ERR_PARAM_ADDRESS;          /* If no, return error */
 187              		.loc 1 301 0
 188 003c 8923     		movs	r3, #137
 189 003e 15E0     		b	.L7
 190              	.L8:
 302:../Generated_Code/IntFlashLdd1.c ****   }
 303:../Generated_Code/IntFlashLdd1.c ****   /* Filling of the internal state structure */
 304:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentOperation = LDD_FLASH_WRITE; /* Set the current operation type */
 191              		.loc 1 304 0
 192 0040 7B69     		ldr	r3, [r7, #20]
 193 0042 0222     		movs	r2, #2
 194 0044 1A70     		strb	r2, [r3]
 305:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentOperationStatus = LDD_FLASH_START; /* Set the current operation status to S
 195              		.loc 1 305 0
 196 0046 7B69     		ldr	r3, [r7, #20]
 197 0048 0422     		movs	r2, #4
 198 004a 5A70     		strb	r2, [r3, #1]
 306:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentCommand = LDD_FLASH_WRITE_PHRASE; /* Set the flash command to be proceed fo
 199              		.loc 1 306 0
 200 004c 7B69     		ldr	r3, [r7, #20]
 201 004e 0722     		movs	r2, #7
 202 0050 9A70     		strb	r2, [r3, #2]
 307:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->DataCounter = Size;   /* Reset Data counter */
 203              		.loc 1 307 0
 204 0052 7B69     		ldr	r3, [r7, #20]
 205 0054 3A68     		ldr	r2, [r7]
 206 0056 9A60     		str	r2, [r3, #8]
 308:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentDataPtr = (uint8_t *)FromPtr; /* Reset the "From pointer" for the operation
 207              		.loc 1 308 0
 208 0058 7B69     		ldr	r3, [r7, #20]
 209 005a BA68     		ldr	r2, [r7, #8]
 210 005c DA60     		str	r2, [r3, #12]
 309:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentFlashAddress = ToAddress; /* Reset the "To address" for the operation */
 211              		.loc 1 309 0
 212 005e 7B69     		ldr	r3, [r7, #20]
 213 0060 7A68     		ldr	r2, [r7, #4]
 214 0062 1A61     		str	r2, [r3, #16]
 310:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentDataSize = 0U; /* Reset Current data size */
 215              		.loc 1 310 0
 216 0064 7B69     		ldr	r3, [r7, #20]
 217 0066 0022     		movs	r2, #0
 218 0068 5A60     		str	r2, [r3, #4]
 311:../Generated_Code/IntFlashLdd1.c ****   return ERR_OK;                       /* Return with no error */
 219              		.loc 1 311 0
 220 006a 0023     		movs	r3, #0
 221              	.L7:
 312:../Generated_Code/IntFlashLdd1.c **** }
 222              		.loc 1 312 0
 223 006c 1846     		mov	r0, r3
 224 006e 1837     		adds	r7, r7, #24
 225 0070 BD46     		mov	sp, r7
 226              		@ sp needed
 227 0072 80BD     		pop	{r7, pc}
 228              		.cfi_endproc
 229              	.LFE1:
 231              		.section	.text.IntFlashLdd1_Read,"ax",%progbits
 232              		.align	2
 233              		.global	IntFlashLdd1_Read
 234              		.thumb
 235              		.thumb_func
 237              	IntFlashLdd1_Read:
 238              	.LFB2:
 313:../Generated_Code/IntFlashLdd1.c **** 
 314:../Generated_Code/IntFlashLdd1.c **** /*
 315:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 316:../Generated_Code/IntFlashLdd1.c **** **     Method      :  IntFlashLdd1_Read (component FLASH_LDD)
 317:../Generated_Code/IntFlashLdd1.c **** */
 318:../Generated_Code/IntFlashLdd1.c **** /*!
 319:../Generated_Code/IntFlashLdd1.c **** **     @brief
 320:../Generated_Code/IntFlashLdd1.c **** **         This method sets up a flash memory read operation. The
 321:../Generated_Code/IntFlashLdd1.c **** **         operation itself is performing by defined batches (property
 322:../Generated_Code/IntFlashLdd1.c **** **         [Read batch size]) by periodical calling the component’s
 323:../Generated_Code/IntFlashLdd1.c **** **         Main method in the user application (higher level OS service).
 324:../Generated_Code/IntFlashLdd1.c **** **     @param
 325:../Generated_Code/IntFlashLdd1.c **** **         DeviceDataPtr   - Device data structure
 326:../Generated_Code/IntFlashLdd1.c **** **                           pointer returned by [Init] method.
 327:../Generated_Code/IntFlashLdd1.c **** **     @param
 328:../Generated_Code/IntFlashLdd1.c **** **         FromAddress     - Address to the flash
 329:../Generated_Code/IntFlashLdd1.c **** **                           memory the output data would be read from.
 330:../Generated_Code/IntFlashLdd1.c **** **     @param
 331:../Generated_Code/IntFlashLdd1.c **** **         ToPtr           - Pointer to a location the data would
 332:../Generated_Code/IntFlashLdd1.c **** **                           be written to.
 333:../Generated_Code/IntFlashLdd1.c **** **     @param
 334:../Generated_Code/IntFlashLdd1.c **** **         Size            - Size of the data (in bytes)  to be read
 335:../Generated_Code/IntFlashLdd1.c **** **                           from the flash memory.
 336:../Generated_Code/IntFlashLdd1.c **** **     @return
 337:../Generated_Code/IntFlashLdd1.c **** **                         - Error code
 338:../Generated_Code/IntFlashLdd1.c **** **                           ERR_OK - OK
 339:../Generated_Code/IntFlashLdd1.c **** **                           ERR_DISABLED - Component is disabled
 340:../Generated_Code/IntFlashLdd1.c **** **                           ERR_SPEED - This device does not work in
 341:../Generated_Code/IntFlashLdd1.c **** **                           the active clock configuration
 342:../Generated_Code/IntFlashLdd1.c **** **                           ERR_BUSY - Some flash memory operation is
 343:../Generated_Code/IntFlashLdd1.c **** **                           already in progress 
 344:../Generated_Code/IntFlashLdd1.c **** **                           ERR_PARAM_ADDRESS - Desired flash memory
 345:../Generated_Code/IntFlashLdd1.c **** **                           area is out of allowed range
 346:../Generated_Code/IntFlashLdd1.c **** */
 347:../Generated_Code/IntFlashLdd1.c **** /* ===================================================================*/
 348:../Generated_Code/IntFlashLdd1.c **** LDD_TError IntFlashLdd1_Read(LDD_TDeviceData *DeviceDataPtr, LDD_FLASH_TAddress FromAddress, LDD_TD
 349:../Generated_Code/IntFlashLdd1.c **** {
 239              		.loc 1 349 0
 240              		.cfi_startproc
 241              		@ args = 0, pretend = 0, frame = 24
 242              		@ frame_needed = 1, uses_anonymous_args = 0
 243 0000 80B5     		push	{r7, lr}
 244              		.cfi_def_cfa_offset 8
 245              		.cfi_offset 7, -8
 246              		.cfi_offset 14, -4
 247 0002 86B0     		sub	sp, sp, #24
 248              		.cfi_def_cfa_offset 32
 249 0004 00AF     		add	r7, sp, #0
 250              		.cfi_def_cfa_register 7
 251 0006 F860     		str	r0, [r7, #12]
 252 0008 B960     		str	r1, [r7, #8]
 253 000a 7A60     		str	r2, [r7, #4]
 254 000c 3B60     		str	r3, [r7]
 350:../Generated_Code/IntFlashLdd1.c ****   IntFlashLdd1_TDeviceDataPtr DeviceDataPrv = (IntFlashLdd1_TDeviceDataPtr)DeviceDataPtr; /* Auxili
 255              		.loc 1 350 0
 256 000e FB68     		ldr	r3, [r7, #12]
 257 0010 7B61     		str	r3, [r7, #20]
 351:../Generated_Code/IntFlashLdd1.c **** 
 352:../Generated_Code/IntFlashLdd1.c ****   if (!(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_IDLE) && /* If some operation is already
 258              		.loc 1 352 0
 259 0012 7B69     		ldr	r3, [r7, #20]
 260 0014 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 261 0016 022B     		cmp	r3, #2
 262 0018 09D0     		beq	.L10
 353:../Generated_Code/IntFlashLdd1.c ****      !(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_STOP) && \
 263              		.loc 1 353 0 discriminator 1
 264 001a 7B69     		ldr	r3, [r7, #20]
 265 001c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 352:../Generated_Code/IntFlashLdd1.c ****   if (!(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_IDLE) && /* If some operation is already
 266              		.loc 1 352 0 discriminator 1
 267 001e 012B     		cmp	r3, #1
 268 0020 05D0     		beq	.L10
 354:../Generated_Code/IntFlashLdd1.c ****      !(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_FAILED)) {
 269              		.loc 1 354 0
 270 0022 7B69     		ldr	r3, [r7, #20]
 271 0024 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 353:../Generated_Code/IntFlashLdd1.c ****      !(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_STOP) && \
 272              		.loc 1 353 0
 273 0026 002B     		cmp	r3, #0
 274 0028 01D0     		beq	.L10
 355:../Generated_Code/IntFlashLdd1.c ****     return ERR_BUSY;
 275              		.loc 1 355 0
 276 002a 0823     		movs	r3, #8
 277 002c 1BE0     		b	.L11
 278              	.L10:
 356:../Generated_Code/IntFlashLdd1.c ****   }
 357:../Generated_Code/IntFlashLdd1.c ****   if (RangeCheck(FromAddress, Size) != (LDD_TError)ERR_OK) {
 279              		.loc 1 357 0
 280 002e B868     		ldr	r0, [r7, #8]
 281 0030 3968     		ldr	r1, [r7]
 282 0032 FFF7FEFF 		bl	RangeCheck
 283 0036 0346     		mov	r3, r0
 284 0038 002B     		cmp	r3, #0
 285 003a 01D0     		beq	.L12
 358:../Generated_Code/IntFlashLdd1.c ****     return ERR_PARAM_ADDRESS;
 286              		.loc 1 358 0
 287 003c 8923     		movs	r3, #137
 288 003e 12E0     		b	.L11
 289              	.L12:
 359:../Generated_Code/IntFlashLdd1.c ****   }
 360:../Generated_Code/IntFlashLdd1.c ****   /* Filling of the internal state structure */
 361:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentOperation = LDD_FLASH_READ; /* Set the current operation type */
 290              		.loc 1 361 0
 291 0040 7B69     		ldr	r3, [r7, #20]
 292 0042 0122     		movs	r2, #1
 293 0044 1A70     		strb	r2, [r3]
 362:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentOperationStatus = LDD_FLASH_START; /* Set the current operation status to S
 294              		.loc 1 362 0
 295 0046 7B69     		ldr	r3, [r7, #20]
 296 0048 0422     		movs	r2, #4
 297 004a 5A70     		strb	r2, [r3, #1]
 363:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->DataCounter = Size;   /* Reset Data counter */
 298              		.loc 1 363 0
 299 004c 7B69     		ldr	r3, [r7, #20]
 300 004e 3A68     		ldr	r2, [r7]
 301 0050 9A60     		str	r2, [r3, #8]
 364:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentDataPtr = (uint8_t *)ToPtr; /* Reset the "To pointer" for the operation */
 302              		.loc 1 364 0
 303 0052 7B69     		ldr	r3, [r7, #20]
 304 0054 7A68     		ldr	r2, [r7, #4]
 305 0056 DA60     		str	r2, [r3, #12]
 365:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentFlashAddress = FromAddress; /* Reset the "From address" for the operation *
 306              		.loc 1 365 0
 307 0058 7B69     		ldr	r3, [r7, #20]
 308 005a BA68     		ldr	r2, [r7, #8]
 309 005c 1A61     		str	r2, [r3, #16]
 366:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentDataSize = 1U; /* Set the current data size */
 310              		.loc 1 366 0
 311 005e 7B69     		ldr	r3, [r7, #20]
 312 0060 0122     		movs	r2, #1
 313 0062 5A60     		str	r2, [r3, #4]
 367:../Generated_Code/IntFlashLdd1.c ****   return ERR_OK;                       /* Return with no error */
 314              		.loc 1 367 0
 315 0064 0023     		movs	r3, #0
 316              	.L11:
 368:../Generated_Code/IntFlashLdd1.c **** }
 317              		.loc 1 368 0
 318 0066 1846     		mov	r0, r3
 319 0068 1837     		adds	r7, r7, #24
 320 006a BD46     		mov	sp, r7
 321              		@ sp needed
 322 006c 80BD     		pop	{r7, pc}
 323              		.cfi_endproc
 324              	.LFE2:
 326 006e 00BF     		.section	.text.IntFlashLdd1_Erase,"ax",%progbits
 327              		.align	2
 328              		.global	IntFlashLdd1_Erase
 329              		.thumb
 330              		.thumb_func
 332              	IntFlashLdd1_Erase:
 333              	.LFB3:
 369:../Generated_Code/IntFlashLdd1.c **** 
 370:../Generated_Code/IntFlashLdd1.c **** /*
 371:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 372:../Generated_Code/IntFlashLdd1.c **** **     Method      :  IntFlashLdd1_Erase (component FLASH_LDD)
 373:../Generated_Code/IntFlashLdd1.c **** */
 374:../Generated_Code/IntFlashLdd1.c **** /*!
 375:../Generated_Code/IntFlashLdd1.c **** **     @brief
 376:../Generated_Code/IntFlashLdd1.c **** **         This method sets up a flash memory erase operation. The
 377:../Generated_Code/IntFlashLdd1.c **** **         operation itself is performing by defined batches (property
 378:../Generated_Code/IntFlashLdd1.c **** **         [Erase batch size]) by periodical calling the component’s
 379:../Generated_Code/IntFlashLdd1.c **** **         Main method in the user application (higher level OS service)
 380:../Generated_Code/IntFlashLdd1.c **** **         or by the component’s ISR, if an component’s interrupt
 381:../Generated_Code/IntFlashLdd1.c **** **         service is enabled.
 382:../Generated_Code/IntFlashLdd1.c **** **     @param
 383:../Generated_Code/IntFlashLdd1.c **** **         DeviceDataPtr   - Device data structure
 384:../Generated_Code/IntFlashLdd1.c **** **                           pointer returned by [Init] method.
 385:../Generated_Code/IntFlashLdd1.c **** **     @param
 386:../Generated_Code/IntFlashLdd1.c **** **         FromAddress     - Address of the flash
 387:../Generated_Code/IntFlashLdd1.c **** **                           memory area (the first erase sector is the
 388:../Generated_Code/IntFlashLdd1.c **** **                           sector the given address belongs to) to be
 389:../Generated_Code/IntFlashLdd1.c **** **                           erased.
 390:../Generated_Code/IntFlashLdd1.c **** **     @param
 391:../Generated_Code/IntFlashLdd1.c **** **         Size            - Size of the flash memory area (in bytes)
 392:../Generated_Code/IntFlashLdd1.c **** **                           to be erased. The flash memory is erased by
 393:../Generated_Code/IntFlashLdd1.c **** **                           the erase sectors. The first erased sector
 394:../Generated_Code/IntFlashLdd1.c **** **                           is a sector the address specified by the
 395:../Generated_Code/IntFlashLdd1.c **** **                           input parameter Address belongs to. The
 396:../Generated_Code/IntFlashLdd1.c **** **                           last erased sector is a sector the address
 397:../Generated_Code/IntFlashLdd1.c **** **                           calculated like an addition of the address
 398:../Generated_Code/IntFlashLdd1.c **** **                           specified by the input parameter Address
 399:../Generated_Code/IntFlashLdd1.c **** **                           and the size specified by the input
 400:../Generated_Code/IntFlashLdd1.c **** **                           parameter Size belongs to.
 401:../Generated_Code/IntFlashLdd1.c **** **     @return
 402:../Generated_Code/IntFlashLdd1.c **** **                         - Error code
 403:../Generated_Code/IntFlashLdd1.c **** **                           ERR_OK - OK
 404:../Generated_Code/IntFlashLdd1.c **** **                           ERR_DISABLED - Component is disabled
 405:../Generated_Code/IntFlashLdd1.c **** **                           ERR_SPEED - This device does not work in
 406:../Generated_Code/IntFlashLdd1.c **** **                           the active clock configuration
 407:../Generated_Code/IntFlashLdd1.c **** **                           ERR_BUSY - Some flash memory operation is
 408:../Generated_Code/IntFlashLdd1.c **** **                           already in progress 
 409:../Generated_Code/IntFlashLdd1.c **** **                           ERR_PARAM_ADDRESS - Desired flash memory
 410:../Generated_Code/IntFlashLdd1.c **** **                           area is out of allowed range or is not
 411:../Generated_Code/IntFlashLdd1.c **** **                           aligned to erasable units' bounderies
 412:../Generated_Code/IntFlashLdd1.c **** **                           ERR_NOTAVAIL - When Safe launch and wait
 413:../Generated_Code/IntFlashLdd1.c **** **                           mode is enabled (property Safe launch and
 414:../Generated_Code/IntFlashLdd1.c **** **                           wait) and safe routine location is defined
 415:../Generated_Code/IntFlashLdd1.c **** **                           in runtime (property Safe routine location)
 416:../Generated_Code/IntFlashLdd1.c **** **                           and the safe routine location has not been
 417:../Generated_Code/IntFlashLdd1.c **** **                           specified yet (the SetSafeRoutineLocation
 418:../Generated_Code/IntFlashLdd1.c **** **                           method has not been used to define the
 419:../Generated_Code/IntFlashLdd1.c **** **                           location the safe routine will be copied to).
 420:../Generated_Code/IntFlashLdd1.c **** */
 421:../Generated_Code/IntFlashLdd1.c **** /* ===================================================================*/
 422:../Generated_Code/IntFlashLdd1.c **** 
 423:../Generated_Code/IntFlashLdd1.c **** LDD_TError IntFlashLdd1_Erase(LDD_TDeviceData *DeviceDataPtr, LDD_FLASH_TAddress FromAddress, LDD_F
 424:../Generated_Code/IntFlashLdd1.c **** {
 334              		.loc 1 424 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 24
 337              		@ frame_needed = 1, uses_anonymous_args = 0
 338 0000 80B5     		push	{r7, lr}
 339              		.cfi_def_cfa_offset 8
 340              		.cfi_offset 7, -8
 341              		.cfi_offset 14, -4
 342 0002 86B0     		sub	sp, sp, #24
 343              		.cfi_def_cfa_offset 32
 344 0004 00AF     		add	r7, sp, #0
 345              		.cfi_def_cfa_register 7
 346 0006 F860     		str	r0, [r7, #12]
 347 0008 B960     		str	r1, [r7, #8]
 348 000a 7A60     		str	r2, [r7, #4]
 425:../Generated_Code/IntFlashLdd1.c ****   IntFlashLdd1_TDeviceDataPtr DeviceDataPrv = (IntFlashLdd1_TDeviceDataPtr)DeviceDataPtr; /* Auxili
 349              		.loc 1 425 0
 350 000c FB68     		ldr	r3, [r7, #12]
 351 000e 3B61     		str	r3, [r7, #16]
 426:../Generated_Code/IntFlashLdd1.c ****   uint32_t EraseUnitMask;
 427:../Generated_Code/IntFlashLdd1.c ****   
 428:../Generated_Code/IntFlashLdd1.c ****   if (!(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_IDLE) && /* If some operation is already
 352              		.loc 1 428 0
 353 0010 3B69     		ldr	r3, [r7, #16]
 354 0012 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 355 0014 022B     		cmp	r3, #2
 356 0016 09D0     		beq	.L14
 429:../Generated_Code/IntFlashLdd1.c ****      !(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_STOP) && \
 357              		.loc 1 429 0 discriminator 1
 358 0018 3B69     		ldr	r3, [r7, #16]
 359 001a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 428:../Generated_Code/IntFlashLdd1.c ****   if (!(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_IDLE) && /* If some operation is already
 360              		.loc 1 428 0 discriminator 1
 361 001c 012B     		cmp	r3, #1
 362 001e 05D0     		beq	.L14
 430:../Generated_Code/IntFlashLdd1.c ****      !(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_FAILED)) {
 363              		.loc 1 430 0
 364 0020 3B69     		ldr	r3, [r7, #16]
 365 0022 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 429:../Generated_Code/IntFlashLdd1.c ****      !(DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_STOP) && \
 366              		.loc 1 429 0
 367 0024 002B     		cmp	r3, #0
 368 0026 01D0     		beq	.L14
 431:../Generated_Code/IntFlashLdd1.c ****     return ERR_BUSY;
 369              		.loc 1 431 0
 370 0028 0823     		movs	r3, #8
 371 002a 36E0     		b	.L15
 372              	.L14:
 432:../Generated_Code/IntFlashLdd1.c ****   }
 433:../Generated_Code/IntFlashLdd1.c ****   if (FromAddress >= IntFlashLdd1_DFLASH_ADDRESS) {
 373              		.loc 1 433 0
 374 002c BB68     		ldr	r3, [r7, #8]
 375 002e B3F1805F 		cmp	r3, #268435456
 376 0032 03D3     		bcc	.L16
 434:../Generated_Code/IntFlashLdd1.c ****     EraseUnitMask = IntFlashLdd1_DFLASH_ERASABLE_UNIT_SIZE - 1U; /* Set the current data size */
 377              		.loc 1 434 0
 378 0034 40F6FF73 		movw	r3, #4095
 379 0038 7B61     		str	r3, [r7, #20]
 380 003a 02E0     		b	.L17
 381              	.L16:
 435:../Generated_Code/IntFlashLdd1.c ****   } else {
 436:../Generated_Code/IntFlashLdd1.c ****     EraseUnitMask = IntFlashLdd1_PFLASH_ERASABLE_UNIT_SIZE - 1U; /* Set the current data size */
 382              		.loc 1 436 0
 383 003c 40F6FF73 		movw	r3, #4095
 384 0040 7B61     		str	r3, [r7, #20]
 385              	.L17:
 437:../Generated_Code/IntFlashLdd1.c ****   }
 438:../Generated_Code/IntFlashLdd1.c ****   if (RangeCheck(FromAddress, Size) != (LDD_TError)ERR_OK) { /* Is an address range of desired oper
 386              		.loc 1 438 0
 387 0042 B868     		ldr	r0, [r7, #8]
 388 0044 7968     		ldr	r1, [r7, #4]
 389 0046 FFF7FEFF 		bl	RangeCheck
 390 004a 0346     		mov	r3, r0
 391 004c 002B     		cmp	r3, #0
 392 004e 01D0     		beq	.L18
 439:../Generated_Code/IntFlashLdd1.c ****     return ERR_PARAM_ADDRESS;          /* If yes, return error. */
 393              		.loc 1 439 0
 394 0050 8923     		movs	r3, #137
 395 0052 22E0     		b	.L15
 396              	.L18:
 440:../Generated_Code/IntFlashLdd1.c ****   }
 441:../Generated_Code/IntFlashLdd1.c ****   if (((FromAddress & EraseUnitMask) != 0U) || ((Size & EraseUnitMask) != 0U)){ /* Is the desired a
 397              		.loc 1 441 0
 398 0054 BA68     		ldr	r2, [r7, #8]
 399 0056 7B69     		ldr	r3, [r7, #20]
 400 0058 1340     		ands	r3, r3, r2
 401 005a 002B     		cmp	r3, #0
 402 005c 04D1     		bne	.L19
 403              		.loc 1 441 0 is_stmt 0 discriminator 1
 404 005e 7A68     		ldr	r2, [r7, #4]
 405 0060 7B69     		ldr	r3, [r7, #20]
 406 0062 1340     		ands	r3, r3, r2
 407 0064 002B     		cmp	r3, #0
 408 0066 01D0     		beq	.L20
 409              	.L19:
 442:../Generated_Code/IntFlashLdd1.c ****     return ERR_PARAM_ADDRESS;          /* If yes, return error. */
 410              		.loc 1 442 0 is_stmt 1
 411 0068 8923     		movs	r3, #137
 412 006a 16E0     		b	.L15
 413              	.L20:
 443:../Generated_Code/IntFlashLdd1.c ****   }
 444:../Generated_Code/IntFlashLdd1.c ****   /* Filling of the internal state structure */
 445:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentOperation = LDD_FLASH_ERASE; /* Set the current operation type */
 414              		.loc 1 445 0
 415 006c 3B69     		ldr	r3, [r7, #16]
 416 006e 0322     		movs	r2, #3
 417 0070 1A70     		strb	r2, [r3]
 446:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentOperationStatus = LDD_FLASH_START; /* Set the current operation status to S
 418              		.loc 1 446 0
 419 0072 3B69     		ldr	r3, [r7, #16]
 420 0074 0422     		movs	r2, #4
 421 0076 5A70     		strb	r2, [r3, #1]
 447:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->DataCounter = Size;   /* Reset Data counter */
 422              		.loc 1 447 0
 423 0078 3B69     		ldr	r3, [r7, #16]
 424 007a 7A68     		ldr	r2, [r7, #4]
 425 007c 9A60     		str	r2, [r3, #8]
 448:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentDataPtr = NULL; /* Reset the "Data pointer" for the operation */
 426              		.loc 1 448 0
 427 007e 3B69     		ldr	r3, [r7, #16]
 428 0080 0022     		movs	r2, #0
 429 0082 DA60     		str	r2, [r3, #12]
 449:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentFlashAddress = FromAddress; /* Reset the "From address" for the operation *
 430              		.loc 1 449 0
 431 0084 3B69     		ldr	r3, [r7, #16]
 432 0086 BA68     		ldr	r2, [r7, #8]
 433 0088 1A61     		str	r2, [r3, #16]
 450:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentDataSize = EraseUnitMask+1; /* Set the current data size */
 434              		.loc 1 450 0
 435 008a 7B69     		ldr	r3, [r7, #20]
 436 008c 5A1C     		adds	r2, r3, #1
 437 008e 3B69     		ldr	r3, [r7, #16]
 438 0090 5A60     		str	r2, [r3, #4]
 451:../Generated_Code/IntFlashLdd1.c ****   DeviceDataPrv->CurrentCommand = LDD_FLASH_ERASE_SECTOR; /* Set the current operation flash comman
 439              		.loc 1 451 0
 440 0092 3B69     		ldr	r3, [r7, #16]
 441 0094 0922     		movs	r2, #9
 442 0096 9A70     		strb	r2, [r3, #2]
 452:../Generated_Code/IntFlashLdd1.c ****   return ERR_OK;                       /* Return with no error */
 443              		.loc 1 452 0
 444 0098 0023     		movs	r3, #0
 445              	.L15:
 453:../Generated_Code/IntFlashLdd1.c **** }
 446              		.loc 1 453 0
 447 009a 1846     		mov	r0, r3
 448 009c 1837     		adds	r7, r7, #24
 449 009e BD46     		mov	sp, r7
 450              		@ sp needed
 451 00a0 80BD     		pop	{r7, pc}
 452              		.cfi_endproc
 453              	.LFE3:
 455 00a2 00BF     		.section	.text.IntFlashLdd1_GetOperationStatus,"ax",%progbits
 456              		.align	2
 457              		.global	IntFlashLdd1_GetOperationStatus
 458              		.thumb
 459              		.thumb_func
 461              	IntFlashLdd1_GetOperationStatus:
 462              	.LFB4:
 454:../Generated_Code/IntFlashLdd1.c **** 
 455:../Generated_Code/IntFlashLdd1.c **** /*
 456:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 457:../Generated_Code/IntFlashLdd1.c **** **     Method      :  IntFlashLdd1_GetOperationStatus (component FLASH_LDD)
 458:../Generated_Code/IntFlashLdd1.c **** */
 459:../Generated_Code/IntFlashLdd1.c **** /*!
 460:../Generated_Code/IntFlashLdd1.c **** **     @brief
 461:../Generated_Code/IntFlashLdd1.c **** **         Returns a status of current (last) flash memory operation.
 462:../Generated_Code/IntFlashLdd1.c **** **     @param
 463:../Generated_Code/IntFlashLdd1.c **** **         DeviceDataPtr   - Device data structure
 464:../Generated_Code/IntFlashLdd1.c **** **                           pointer returned by [Init] method.
 465:../Generated_Code/IntFlashLdd1.c **** **     @return
 466:../Generated_Code/IntFlashLdd1.c **** **                         - Current flash memory operation status. See
 467:../Generated_Code/IntFlashLdd1.c **** **                           the LDD_FLASH_TOperationStatus type's
 468:../Generated_Code/IntFlashLdd1.c **** **                           description for details.
 469:../Generated_Code/IntFlashLdd1.c **** */
 470:../Generated_Code/IntFlashLdd1.c **** /* ===================================================================*/
 471:../Generated_Code/IntFlashLdd1.c **** LDD_FLASH_TOperationStatus IntFlashLdd1_GetOperationStatus(LDD_TDeviceData *DeviceDataPtr)
 472:../Generated_Code/IntFlashLdd1.c **** {
 463              		.loc 1 472 0
 464              		.cfi_startproc
 465              		@ args = 0, pretend = 0, frame = 8
 466              		@ frame_needed = 1, uses_anonymous_args = 0
 467              		@ link register save eliminated.
 468 0000 80B4     		push	{r7}
 469              		.cfi_def_cfa_offset 4
 470              		.cfi_offset 7, -4
 471 0002 83B0     		sub	sp, sp, #12
 472              		.cfi_def_cfa_offset 16
 473 0004 00AF     		add	r7, sp, #0
 474              		.cfi_def_cfa_register 7
 475 0006 7860     		str	r0, [r7, #4]
 473:../Generated_Code/IntFlashLdd1.c ****   return ((IntFlashLdd1_TDeviceDataPtr)(DeviceDataPtr))->CurrentOperationStatus; /* Return current 
 476              		.loc 1 473 0
 477 0008 7B68     		ldr	r3, [r7, #4]
 478 000a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 474:../Generated_Code/IntFlashLdd1.c **** }
 479              		.loc 1 474 0
 480 000c 1846     		mov	r0, r3
 481 000e 0C37     		adds	r7, r7, #12
 482 0010 BD46     		mov	sp, r7
 483              		@ sp needed
 484 0012 5DF8047B 		ldr	r7, [sp], #4
 485 0016 7047     		bx	lr
 486              		.cfi_endproc
 487              	.LFE4:
 489              		.section	.rodata
 490              		.align	2
 491              	.LC0:
 492 0000 FFFFFFFF 		.word	-1
 493 0004 FFFFFFFF 		.word	-1
 494              		.section	.text.IntFlashLdd1_Main,"ax",%progbits
 495              		.align	2
 496              		.global	IntFlashLdd1_Main
 497              		.thumb
 498              		.thumb_func
 500              	IntFlashLdd1_Main:
 501              	.LFB5:
 475:../Generated_Code/IntFlashLdd1.c **** 
 476:../Generated_Code/IntFlashLdd1.c **** /*
 477:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 478:../Generated_Code/IntFlashLdd1.c **** **     Method      :  IntFlashLdd1_Main (component FLASH_LDD)
 479:../Generated_Code/IntFlashLdd1.c **** */
 480:../Generated_Code/IntFlashLdd1.c **** /*!
 481:../Generated_Code/IntFlashLdd1.c **** **     @brief
 482:../Generated_Code/IntFlashLdd1.c **** **         This method is used to perform one batch of a flash memory
 483:../Generated_Code/IntFlashLdd1.c **** **         operation. This method is used to perform batches of all
 484:../Generated_Code/IntFlashLdd1.c **** **         flash memory operations (Write, Read, Erase, EraseBlock,
 485:../Generated_Code/IntFlashLdd1.c **** **         VerifyErasedBlock) when the component works in the polled
 486:../Generated_Code/IntFlashLdd1.c **** **         mode (interrupt service is disabled - property [Interrupt
 487:../Generated_Code/IntFlashLdd1.c **** **         service]). This method performs batches of the read flash
 488:../Generated_Code/IntFlashLdd1.c **** **         memory operation, when the component works in the interrupt
 489:../Generated_Code/IntFlashLdd1.c **** **         triggered mode (interrupt service is enabled). This method
 490:../Generated_Code/IntFlashLdd1.c **** **         is enabled only if the component works in the polled mode or
 491:../Generated_Code/IntFlashLdd1.c **** **         if the Read method is enabled.
 492:../Generated_Code/IntFlashLdd1.c **** **     @param
 493:../Generated_Code/IntFlashLdd1.c **** **         DeviceDataPtr   - Device data structure
 494:../Generated_Code/IntFlashLdd1.c **** **                           pointer returned by [Init] method.
 495:../Generated_Code/IntFlashLdd1.c **** */
 496:../Generated_Code/IntFlashLdd1.c **** /* ===================================================================*/
 497:../Generated_Code/IntFlashLdd1.c **** #define FLEX_MEMORY_BASE_ADDRESS    0x10000000U
 498:../Generated_Code/IntFlashLdd1.c **** #define FLEX_MEMORY_ADDRESS_SWITCH  0x00800000U
 499:../Generated_Code/IntFlashLdd1.c **** #define UNLIMITED_BATCH_SIZE 0U
 500:../Generated_Code/IntFlashLdd1.c **** #define WRITE_BATCH_SIZE 1U
 501:../Generated_Code/IntFlashLdd1.c **** #define ERASE_BATCH_SIZE 1U
 502:../Generated_Code/IntFlashLdd1.c **** #define READ_BATCH_SIZE UNLIMITED_BATCH_SIZE
 503:../Generated_Code/IntFlashLdd1.c **** #define WRITABLE_UNIT_MASK 7U
 504:../Generated_Code/IntFlashLdd1.c **** 
 505:../Generated_Code/IntFlashLdd1.c **** void IntFlashLdd1_Main(LDD_TDeviceData *DeviceDataPtr)
 506:../Generated_Code/IntFlashLdd1.c **** {
 502              		.loc 1 506 0
 503              		.cfi_startproc
 504              		@ args = 0, pretend = 0, frame = 56
 505              		@ frame_needed = 1, uses_anonymous_args = 0
 506 0000 80B5     		push	{r7, lr}
 507              		.cfi_def_cfa_offset 8
 508              		.cfi_offset 7, -8
 509              		.cfi_offset 14, -4
 510 0002 8EB0     		sub	sp, sp, #56
 511              		.cfi_def_cfa_offset 64
 512 0004 00AF     		add	r7, sp, #0
 513              		.cfi_def_cfa_register 7
 514 0006 7860     		str	r0, [r7, #4]
 507:../Generated_Code/IntFlashLdd1.c ****   IntFlashLdd1_TDeviceDataPtr DeviceDataPrv = (IntFlashLdd1_TDeviceDataPtr)DeviceDataPtr; /* Auxili
 515              		.loc 1 507 0
 516 0008 7B68     		ldr	r3, [r7, #4]
 517 000a BB62     		str	r3, [r7, #40]
 508:../Generated_Code/IntFlashLdd1.c ****   uint32_t DataToPrg[0x02] = {0xFFFFFFFFLU,0xFFFFFFFFLU}; /* Auxiliary variable - current data to b
 518              		.loc 1 508 0
 519 000c 974A     		ldr	r2, .L58
 520 000e 07F11803 		add	r3, r7, #24
 521 0012 92E80300 		ldmia	r2, {r0, r1}
 522 0016 83E80300 		stmia	r3, {r0, r1}
 509:../Generated_Code/IntFlashLdd1.c ****   uint32_t DataToPrgMask[0x02] = {0U, 0U};
 523              		.loc 1 509 0
 524 001a 0023     		movs	r3, #0
 525 001c 3B61     		str	r3, [r7, #16]
 526 001e 0023     		movs	r3, #0
 527 0020 7B61     		str	r3, [r7, #20]
 510:../Generated_Code/IntFlashLdd1.c ****   uint32_t CurrentFlashPrgUnitData[0x02]; /* Current flash location content */
 511:../Generated_Code/IntFlashLdd1.c ****   uint8_t PrgBytesCount;               /* Auxiliary variable - Current data counter - number of dat
 512:../Generated_Code/IntFlashLdd1.c ****   uint8_t MaxPossiblePrgBytes = 0U;
 528              		.loc 1 512 0
 529 0022 0023     		movs	r3, #0
 530 0024 87F82730 		strb	r3, [r7, #39]
 513:../Generated_Code/IntFlashLdd1.c ****   uint8_t DstAddrOffset = 0U;          /* Offset of the desired flash location to be written from t
 531              		.loc 1 513 0
 532 0028 0023     		movs	r3, #0
 533 002a 87F83630 		strb	r3, [r7, #54]
 514:../Generated_Code/IntFlashLdd1.c ****   uint8_t i;
 515:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TAddress FlashPrgUnitAddr;
 516:../Generated_Code/IntFlashLdd1.c ****   uint16_t StepsOfBatch = 0U;          /* Number of batch cycles to be proceeded */
 534              		.loc 1 516 0
 535 002e 0023     		movs	r3, #0
 536 0030 7B86     		strh	r3, [r7, #50]	@ movhi
 517:../Generated_Code/IntFlashLdd1.c ****   bool NextBatchCycle;                 /* Unlimited batch flag */
 518:../Generated_Code/IntFlashLdd1.c ****   uint8_t CurrentFlags;                /* Auxiliary variable - current hw flags */
 519:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TAddress CurrentFlashAddress; /* Auxiliary variable - Current flash address */
 520:../Generated_Code/IntFlashLdd1.c **** 
 521:../Generated_Code/IntFlashLdd1.c ****   if ((DeviceDataPrv->CurrentOperationStatus != LDD_FLASH_RUNNING) && /* If there is not an operati
 537              		.loc 1 521 0
 538 0032 BB6A     		ldr	r3, [r7, #40]
 539 0034 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 540 0036 052B     		cmp	r3, #5
 541 0038 08D0     		beq	.L24
 522:../Generated_Code/IntFlashLdd1.c ****      (DeviceDataPrv->CurrentOperationStatus != LDD_FLASH_START) && \
 542              		.loc 1 522 0 discriminator 1
 543 003a BB6A     		ldr	r3, [r7, #40]
 544 003c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 521:../Generated_Code/IntFlashLdd1.c ****   if ((DeviceDataPrv->CurrentOperationStatus != LDD_FLASH_RUNNING) && /* If there is not an operati
 545              		.loc 1 521 0 discriminator 1
 546 003e 042B     		cmp	r3, #4
 547 0040 04D0     		beq	.L24
 523:../Generated_Code/IntFlashLdd1.c ****      (DeviceDataPrv->CurrentOperationStatus != LDD_FLASH_STOP_REQ)) {
 548              		.loc 1 523 0
 549 0042 BB6A     		ldr	r3, [r7, #40]
 550 0044 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 522:../Generated_Code/IntFlashLdd1.c ****      (DeviceDataPrv->CurrentOperationStatus != LDD_FLASH_START) && \
 551              		.loc 1 522 0
 552 0046 032B     		cmp	r3, #3
 553 0048 00D0     		beq	.L24
 524:../Generated_Code/IntFlashLdd1.c ****     return;
 554              		.loc 1 524 0
 555 004a 96E1     		b	.L23
 556              	.L24:
 525:../Generated_Code/IntFlashLdd1.c ****   }
 526:../Generated_Code/IntFlashLdd1.c ****   if ((FTFE_PDD_GetFlags(FTFE_BASE_PTR) & FTFE_PDD_COMMAND_COMPLETE) == 0U){ /* If there is some fl
 557              		.loc 1 526 0
 558 004c 884B     		ldr	r3, .L58+4
 559 004e 1B78     		ldrb	r3, [r3]
 560 0050 DBB2     		uxtb	r3, r3
 561 0052 DBB2     		uxtb	r3, r3
 562 0054 5BB2     		sxtb	r3, r3
 563 0056 002B     		cmp	r3, #0
 564 0058 00DB     		blt	.L26
 527:../Generated_Code/IntFlashLdd1.c ****     return;
 565              		.loc 1 527 0
 566 005a 8EE1     		b	.L23
 567              	.L26:
 528:../Generated_Code/IntFlashLdd1.c ****   }
 529:../Generated_Code/IntFlashLdd1.c ****   if (DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_START) { /* Is this run the first run of t
 568              		.loc 1 529 0
 569 005c BB6A     		ldr	r3, [r7, #40]
 570 005e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 571 0060 042B     		cmp	r3, #4
 572 0062 06D1     		bne	.L27
 530:../Generated_Code/IntFlashLdd1.c ****     FTFE_PDD_ClearFlags(FTFE_BASE_PTR, /* If yes, clear hw flags */
 573              		.loc 1 530 0
 574 0064 824B     		ldr	r3, .L58+4
 575 0066 7022     		movs	r2, #112
 576 0068 1A70     		strb	r2, [r3]
 531:../Generated_Code/IntFlashLdd1.c ****                         FTFE_PDD_READ_COLLISION_ERROR | \
 532:../Generated_Code/IntFlashLdd1.c ****                         FTFE_PDD_ACCESS_ERROR | \
 533:../Generated_Code/IntFlashLdd1.c ****                         FTFE_PDD_PROTECTION_VIOLATION);
 534:../Generated_Code/IntFlashLdd1.c ****     DeviceDataPrv->CurrentErrorFlags = 0U; /* Clear Current SW error flags */
 577              		.loc 1 534 0
 578 006a BB6A     		ldr	r3, [r7, #40]
 579 006c 0022     		movs	r2, #0
 580 006e DA70     		strb	r2, [r3, #3]
 581 0070 28E0     		b	.L28
 582              	.L27:
 535:../Generated_Code/IntFlashLdd1.c ****   } else {                             /* If this is not the first run of the operation, checks the
 536:../Generated_Code/IntFlashLdd1.c ****     CurrentFlags = FTFE_PDD_GetFlags(FTFE_BASE_PTR);
 583              		.loc 1 536 0
 584 0072 7F4B     		ldr	r3, .L58+4
 585 0074 1B78     		ldrb	r3, [r3]
 586 0076 87F82630 		strb	r3, [r7, #38]
 537:../Generated_Code/IntFlashLdd1.c ****     DeviceDataPrv->CurrentErrorFlags |= CurrentFlags & /* Save current hw flags */\
 587              		.loc 1 537 0
 588 007a BB6A     		ldr	r3, [r7, #40]
 589 007c DA78     		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 590 007e 97F82630 		ldrb	r3, [r7, #38]
 591 0082 03F07003 		and	r3, r3, #112
 592 0086 DBB2     		uxtb	r3, r3
 593 0088 1343     		orrs	r3, r3, r2
 594 008a DAB2     		uxtb	r2, r3
 595 008c BB6A     		ldr	r3, [r7, #40]
 596 008e DA70     		strb	r2, [r3, #3]
 538:../Generated_Code/IntFlashLdd1.c ****     (FTFE_PDD_READ_COLLISION_ERROR | \
 539:../Generated_Code/IntFlashLdd1.c ****      FTFE_PDD_ACCESS_ERROR | \
 540:../Generated_Code/IntFlashLdd1.c ****      FTFE_PDD_PROTECTION_VIOLATION);
 541:../Generated_Code/IntFlashLdd1.c ****     if (DeviceDataPrv->CurrentErrorFlags != 0U) { /* Has some error occurred? */
 597              		.loc 1 541 0
 598 0090 BB6A     		ldr	r3, [r7, #40]
 599 0092 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 600 0094 002B     		cmp	r3, #0
 601 0096 08D0     		beq	.L29
 542:../Generated_Code/IntFlashLdd1.c ****       DeviceDataPrv->CurrentOperationStatus = LDD_FLASH_FAILED; /* If yes, set the operation state 
 602              		.loc 1 542 0
 603 0098 BB6A     		ldr	r3, [r7, #40]
 604 009a 0022     		movs	r2, #0
 605 009c 5A70     		strb	r2, [r3, #1]
 543:../Generated_Code/IntFlashLdd1.c ****       if (DeviceDataPrv->CurrentOperation != LDD_FLASH_READ) {
 544:../Generated_Code/IntFlashLdd1.c ****       }
 545:../Generated_Code/IntFlashLdd1.c ****       IntFlashLdd1_OnError(DeviceDataPrv->UserDataPtr); /* Invoke the OnError event */
 606              		.loc 1 545 0
 607 009e BB6A     		ldr	r3, [r7, #40]
 608 00a0 5B69     		ldr	r3, [r3, #20]
 609 00a2 1846     		mov	r0, r3
 610 00a4 FFF7FEFF 		bl	IntFlashLdd1_OnError
 546:../Generated_Code/IntFlashLdd1.c ****       return;                          /* End */
 611              		.loc 1 546 0
 612 00a8 67E1     		b	.L23
 613              	.L29:
 547:../Generated_Code/IntFlashLdd1.c ****     }
 548:../Generated_Code/IntFlashLdd1.c ****     if (DeviceDataPrv->DataCounter == 0U) { /* If all the data has been successfully proceeded, fin
 614              		.loc 1 548 0
 615 00aa BB6A     		ldr	r3, [r7, #40]
 616 00ac 9B68     		ldr	r3, [r3, #8]
 617 00ae 002B     		cmp	r3, #0
 618 00b0 08D1     		bne	.L28
 549:../Generated_Code/IntFlashLdd1.c ****       DeviceDataPrv->CurrentOperationStatus = LDD_FLASH_IDLE; /* If yes, change the operation state
 619              		.loc 1 549 0
 620 00b2 BB6A     		ldr	r3, [r7, #40]
 621 00b4 0222     		movs	r2, #2
 622 00b6 5A70     		strb	r2, [r3, #1]
 550:../Generated_Code/IntFlashLdd1.c ****       if (DeviceDataPrv->CurrentOperation != LDD_FLASH_READ) {
 551:../Generated_Code/IntFlashLdd1.c ****       }
 552:../Generated_Code/IntFlashLdd1.c ****       IntFlashLdd1_OnOperationComplete(DeviceDataPrv->UserDataPtr); /* Invoke the OnOperationComple
 623              		.loc 1 552 0
 624 00b8 BB6A     		ldr	r3, [r7, #40]
 625 00ba 5B69     		ldr	r3, [r3, #20]
 626 00bc 1846     		mov	r0, r3
 627 00be FFF7FEFF 		bl	IntFlashLdd1_OnOperationComplete
 553:../Generated_Code/IntFlashLdd1.c ****       return;                          /* End */
 628              		.loc 1 553 0
 629 00c2 5AE1     		b	.L23
 630              	.L28:
 554:../Generated_Code/IntFlashLdd1.c ****     }
 555:../Generated_Code/IntFlashLdd1.c ****   }
 556:../Generated_Code/IntFlashLdd1.c ****   switch (DeviceDataPrv->CurrentOperation) { /* Define the batch counter's initial value according 
 631              		.loc 1 556 0
 632 00c4 BB6A     		ldr	r3, [r7, #40]
 633 00c6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 634 00c8 022B     		cmp	r3, #2
 635 00ca 04D0     		beq	.L31
 636 00cc 032B     		cmp	r3, #3
 637 00ce 05D0     		beq	.L32
 638 00d0 012B     		cmp	r3, #1
 639 00d2 06D0     		beq	.L33
 557:../Generated_Code/IntFlashLdd1.c ****     case LDD_FLASH_WRITE:              /* The current operation is Write */
 558:../Generated_Code/IntFlashLdd1.c ****       StepsOfBatch = WRITE_BATCH_SIZE; /* Initialize the batch counter */
 559:../Generated_Code/IntFlashLdd1.c ****       break;                           /* Break of the case */
 560:../Generated_Code/IntFlashLdd1.c ****     case LDD_FLASH_ERASE:              /* The current operation is Erase */
 561:../Generated_Code/IntFlashLdd1.c ****       StepsOfBatch = ERASE_BATCH_SIZE; /* Initialize the batch counter */
 562:../Generated_Code/IntFlashLdd1.c ****       break;                           /* Break of the case */
 563:../Generated_Code/IntFlashLdd1.c ****     case LDD_FLASH_READ:               /* The current operation is Read */
 564:../Generated_Code/IntFlashLdd1.c ****       StepsOfBatch = READ_BATCH_SIZE;  /* Initialize the batch counter */
 565:../Generated_Code/IntFlashLdd1.c ****       break;                           /* Break of the case */
 566:../Generated_Code/IntFlashLdd1.c ****     default:
 567:../Generated_Code/IntFlashLdd1.c ****       break;
 640              		.loc 1 567 0
 641 00d4 08E0     		b	.L34
 642              	.L31:
 558:../Generated_Code/IntFlashLdd1.c ****       StepsOfBatch = WRITE_BATCH_SIZE; /* Initialize the batch counter */
 643              		.loc 1 558 0
 644 00d6 0123     		movs	r3, #1
 645 00d8 7B86     		strh	r3, [r7, #50]	@ movhi
 559:../Generated_Code/IntFlashLdd1.c ****       break;                           /* Break of the case */
 646              		.loc 1 559 0
 647 00da 05E0     		b	.L34
 648              	.L32:
 561:../Generated_Code/IntFlashLdd1.c ****       StepsOfBatch = ERASE_BATCH_SIZE; /* Initialize the batch counter */
 649              		.loc 1 561 0
 650 00dc 0123     		movs	r3, #1
 651 00de 7B86     		strh	r3, [r7, #50]	@ movhi
 562:../Generated_Code/IntFlashLdd1.c ****       break;                           /* Break of the case */
 652              		.loc 1 562 0
 653 00e0 02E0     		b	.L34
 654              	.L33:
 564:../Generated_Code/IntFlashLdd1.c ****       StepsOfBatch = READ_BATCH_SIZE;  /* Initialize the batch counter */
 655              		.loc 1 564 0
 656 00e2 0023     		movs	r3, #0
 657 00e4 7B86     		strh	r3, [r7, #50]	@ movhi
 565:../Generated_Code/IntFlashLdd1.c ****       break;                           /* Break of the case */
 658              		.loc 1 565 0
 659 00e6 00BF     		nop
 660              	.L34:
 568:../Generated_Code/IntFlashLdd1.c ****   }
 569:../Generated_Code/IntFlashLdd1.c ****   if (StepsOfBatch == UNLIMITED_BATCH_SIZE) { /* Is the unlimited batch of size selected for the cu
 661              		.loc 1 569 0
 662 00e8 7B8E     		ldrh	r3, [r7, #50]
 663 00ea 002B     		cmp	r3, #0
 664 00ec 03D1     		bne	.L35
 570:../Generated_Code/IntFlashLdd1.c ****     NextBatchCycle = TRUE;             /* If the unlimited batch of size is used, set the NextCycle
 665              		.loc 1 570 0
 666 00ee 0123     		movs	r3, #1
 667 00f0 87F83130 		strb	r3, [r7, #49]
 571:../Generated_Code/IntFlashLdd1.c ****   } else {
 572:../Generated_Code/IntFlashLdd1.c ****     NextBatchCycle = FALSE;            /* If the unlimited batch of size is used, set the NextCycle
 573:../Generated_Code/IntFlashLdd1.c ****   }
 574:../Generated_Code/IntFlashLdd1.c ****   while ((StepsOfBatch > 0U) || (NextBatchCycle)) { /* Should another batch of the current operatio
 668              		.loc 1 574 0
 669 00f4 38E1     		b	.L37
 670              	.L35:
 572:../Generated_Code/IntFlashLdd1.c ****     NextBatchCycle = FALSE;            /* If the unlimited batch of size is used, set the NextCycle
 671              		.loc 1 572 0
 672 00f6 0023     		movs	r3, #0
 673 00f8 87F83130 		strb	r3, [r7, #49]
 674              		.loc 1 574 0
 675 00fc 34E1     		b	.L37
 676              	.L56:
 575:../Generated_Code/IntFlashLdd1.c ****     CurrentFlags = FTFE_PDD_GetFlags(FTFE_BASE_PTR); /* Read current hardware flags */
 677              		.loc 1 575 0
 678 00fe 5C4B     		ldr	r3, .L58+4
 679 0100 1B78     		ldrb	r3, [r3]
 680 0102 87F82630 		strb	r3, [r7, #38]
 576:../Generated_Code/IntFlashLdd1.c ****     if ((CurrentFlags & (FTFE_PDD_READ_COLLISION_ERROR /* Check the error flags */\
 681              		.loc 1 576 0
 682 0106 97F82630 		ldrb	r3, [r7, #38]	@ zero_extendqisi2
 683 010a 03F07003 		and	r3, r3, #112
 684 010e 002B     		cmp	r3, #0
 685 0110 00D0     		beq	.L38
 577:../Generated_Code/IntFlashLdd1.c ****                      | FTFE_PDD_ACCESS_ERROR \
 578:../Generated_Code/IntFlashLdd1.c ****                      | FTFE_PDD_PROTECTION_VIOLATION)) != 0U) {
 579:../Generated_Code/IntFlashLdd1.c ****       return;                          /* If there has some error occurred then end. The error will
 686              		.loc 1 579 0
 687 0112 32E1     		b	.L23
 688              	.L38:
 580:../Generated_Code/IntFlashLdd1.c ****     }
 581:../Generated_Code/IntFlashLdd1.c ****     if (DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_START) { /* Is this step the first step 
 689              		.loc 1 581 0
 690 0114 BB6A     		ldr	r3, [r7, #40]
 691 0116 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 692 0118 042B     		cmp	r3, #4
 693 011a 03D1     		bne	.L39
 582:../Generated_Code/IntFlashLdd1.c ****       DeviceDataPrv->CurrentOperationStatus = LDD_FLASH_RUNNING; /* If yes, change Current operatio
 694              		.loc 1 582 0
 695 011c BB6A     		ldr	r3, [r7, #40]
 696 011e 0522     		movs	r2, #5
 697 0120 5A70     		strb	r2, [r3, #1]
 698 0122 15E0     		b	.L40
 699              	.L39:
 583:../Generated_Code/IntFlashLdd1.c ****     } else {
 584:../Generated_Code/IntFlashLdd1.c ****       DeviceDataPrv->CurrentFlashAddress += DeviceDataPrv->CurrentDataSize; /* If no, define of an 
 700              		.loc 1 584 0
 701 0124 BB6A     		ldr	r3, [r7, #40]
 702 0126 1A69     		ldr	r2, [r3, #16]
 703 0128 BB6A     		ldr	r3, [r7, #40]
 704 012a 5B68     		ldr	r3, [r3, #4]
 705 012c 1A44     		add	r2, r2, r3
 706 012e BB6A     		ldr	r3, [r7, #40]
 707 0130 1A61     		str	r2, [r3, #16]
 585:../Generated_Code/IntFlashLdd1.c ****       if ((DeviceDataPrv->CurrentOperation == LDD_FLASH_READ) || (DeviceDataPrv->CurrentOperation =
 708              		.loc 1 585 0
 709 0132 BB6A     		ldr	r3, [r7, #40]
 710 0134 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 711 0136 012B     		cmp	r3, #1
 712 0138 03D0     		beq	.L41
 713              		.loc 1 585 0 is_stmt 0 discriminator 1
 714 013a BB6A     		ldr	r3, [r7, #40]
 715 013c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 716 013e 022B     		cmp	r3, #2
 717 0140 06D1     		bne	.L40
 718              	.L41:
 586:../Generated_Code/IntFlashLdd1.c ****         DeviceDataPrv->CurrentDataPtr += DeviceDataPrv->CurrentDataSize; /* Update of the Current d
 719              		.loc 1 586 0 is_stmt 1
 720 0142 BB6A     		ldr	r3, [r7, #40]
 721 0144 DA68     		ldr	r2, [r3, #12]
 722 0146 BB6A     		ldr	r3, [r7, #40]
 723 0148 5B68     		ldr	r3, [r3, #4]
 724 014a 1A44     		add	r2, r2, r3
 725 014c BB6A     		ldr	r3, [r7, #40]
 726 014e DA60     		str	r2, [r3, #12]
 727              	.L40:
 587:../Generated_Code/IntFlashLdd1.c ****       }
 588:../Generated_Code/IntFlashLdd1.c ****     }
 589:../Generated_Code/IntFlashLdd1.c ****     switch(DeviceDataPrv->CurrentOperation) { /* Perform needed actions for the next step of the op
 728              		.loc 1 589 0
 729 0150 BB6A     		ldr	r3, [r7, #40]
 730 0152 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 731 0154 022B     		cmp	r3, #2
 732 0156 18D0     		beq	.L43
 733 0158 032B     		cmp	r3, #3
 734 015a 0ED0     		beq	.L44
 735 015c 012B     		cmp	r3, #1
 736 015e 00D0     		beq	.L45
 590:../Generated_Code/IntFlashLdd1.c ****       case LDD_FLASH_READ:             /* Read operation */
 591:../Generated_Code/IntFlashLdd1.c ****         *DeviceDataPrv->CurrentDataPtr = *(uint8_t *)DeviceDataPrv->CurrentFlashAddress; /* Read da
 592:../Generated_Code/IntFlashLdd1.c ****         DeviceDataPrv->DataCounter--;  /* Update of the Data counter */
 593:../Generated_Code/IntFlashLdd1.c ****         break;
 594:../Generated_Code/IntFlashLdd1.c ****       case LDD_FLASH_ERASE:            /* Erase operation */
 595:../Generated_Code/IntFlashLdd1.c ****         DeviceDataPrv->DataCounter -= DeviceDataPrv->CurrentDataSize; /* Update of the Data counter
 596:../Generated_Code/IntFlashLdd1.c ****         break;
 597:../Generated_Code/IntFlashLdd1.c ****       case LDD_FLASH_WRITE:
 598:../Generated_Code/IntFlashLdd1.c ****         DstAddrOffset = (uint8_t)DeviceDataPrv->CurrentFlashAddress & WRITABLE_UNIT_MASK; /* Comput
 599:../Generated_Code/IntFlashLdd1.c ****         MaxPossiblePrgBytes = (WRITABLE_UNIT_MASK - DstAddrOffset) + 1U; /* Compute number of bytes
 600:../Generated_Code/IntFlashLdd1.c ****         if (DeviceDataPrv->DataCounter < MaxPossiblePrgBytes) {
 601:../Generated_Code/IntFlashLdd1.c ****           PrgBytesCount = (uint8_t)DeviceDataPrv->DataCounter;
 602:../Generated_Code/IntFlashLdd1.c ****         } else {
 603:../Generated_Code/IntFlashLdd1.c ****           PrgBytesCount = MaxPossiblePrgBytes;
 604:../Generated_Code/IntFlashLdd1.c ****         }
 605:../Generated_Code/IntFlashLdd1.c ****         for (i = 0U; i < PrgBytesCount; i++)  {
 606:../Generated_Code/IntFlashLdd1.c ****           ((uint8_t *)(void *)&DataToPrg)[DstAddrOffset + i] = ((uint8_t *)(void *)(DeviceDataPrv->
 607:../Generated_Code/IntFlashLdd1.c ****           ((uint8_t *)(void *)&DataToPrgMask)[DstAddrOffset + i] = 0xFFu;
 608:../Generated_Code/IntFlashLdd1.c ****         }
 609:../Generated_Code/IntFlashLdd1.c ****         FlashPrgUnitAddr = DeviceDataPrv->CurrentFlashAddress - DstAddrOffset;
 610:../Generated_Code/IntFlashLdd1.c ****         CurrentFlashPrgUnitData[0] = ((uint32_t *)FlashPrgUnitAddr)[0];
 611:../Generated_Code/IntFlashLdd1.c ****         CurrentFlashPrgUnitData[1] = ((uint32_t *)FlashPrgUnitAddr)[1];
 612:../Generated_Code/IntFlashLdd1.c ****         if(((DataToPrg[0] & DataToPrgMask[0]) & (~CurrentFlashPrgUnitData[0])) > 0U) {
 613:../Generated_Code/IntFlashLdd1.c ****           DeviceDataPrv->CurrentErrorFlags |= LDD_FLASH_MULTIPLE_WRITE_ERROR;
 614:../Generated_Code/IntFlashLdd1.c ****           return;
 615:../Generated_Code/IntFlashLdd1.c ****         }
 616:../Generated_Code/IntFlashLdd1.c ****         if(((DataToPrg[1] & DataToPrgMask[1]) & (~CurrentFlashPrgUnitData[1])) > 0U) {
 617:../Generated_Code/IntFlashLdd1.c ****           DeviceDataPrv->CurrentErrorFlags |= LDD_FLASH_MULTIPLE_WRITE_ERROR;
 618:../Generated_Code/IntFlashLdd1.c ****           return;
 619:../Generated_Code/IntFlashLdd1.c ****         }
 620:../Generated_Code/IntFlashLdd1.c ****         DataToPrg[0] = DataToPrg[0] ^ (~CurrentFlashPrgUnitData[0]);
 621:../Generated_Code/IntFlashLdd1.c ****         DataToPrg[1] = DataToPrg[1] ^ (~CurrentFlashPrgUnitData[1]);
 622:../Generated_Code/IntFlashLdd1.c ****         DeviceDataPrv->CurrentDataSize = PrgBytesCount;
 623:../Generated_Code/IntFlashLdd1.c ****         DeviceDataPrv->DataCounter -= PrgBytesCount;
 624:../Generated_Code/IntFlashLdd1.c ****         FTFE_PDD_WriteFCCOBFirstLongWordData(FTFE_BASE_PTR, DataToPrg[0]);
 625:../Generated_Code/IntFlashLdd1.c ****         FTFE_PDD_WriteFCCOBSecondLongWordData(FTFE_BASE_PTR, DataToPrg[1]);
 626:../Generated_Code/IntFlashLdd1.c ****         break;
 627:../Generated_Code/IntFlashLdd1.c ****       default:
 628:../Generated_Code/IntFlashLdd1.c ****         break;
 737              		.loc 1 628 0
 738 0160 C4E0     		b	.L46
 739              	.L45:
 591:../Generated_Code/IntFlashLdd1.c ****         *DeviceDataPrv->CurrentDataPtr = *(uint8_t *)DeviceDataPrv->CurrentFlashAddress; /* Read da
 740              		.loc 1 591 0
 741 0162 BB6A     		ldr	r3, [r7, #40]
 742 0164 DB68     		ldr	r3, [r3, #12]
 743 0166 BA6A     		ldr	r2, [r7, #40]
 744 0168 1269     		ldr	r2, [r2, #16]
 745 016a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 746 016c 1A70     		strb	r2, [r3]
 592:../Generated_Code/IntFlashLdd1.c ****         DeviceDataPrv->DataCounter--;  /* Update of the Data counter */
 747              		.loc 1 592 0
 748 016e BB6A     		ldr	r3, [r7, #40]
 749 0170 9B68     		ldr	r3, [r3, #8]
 750 0172 5A1E     		subs	r2, r3, #1
 751 0174 BB6A     		ldr	r3, [r7, #40]
 752 0176 9A60     		str	r2, [r3, #8]
 593:../Generated_Code/IntFlashLdd1.c ****         break;
 753              		.loc 1 593 0
 754 0178 B8E0     		b	.L46
 755              	.L44:
 595:../Generated_Code/IntFlashLdd1.c ****         DeviceDataPrv->DataCounter -= DeviceDataPrv->CurrentDataSize; /* Update of the Data counter
 756              		.loc 1 595 0
 757 017a BB6A     		ldr	r3, [r7, #40]
 758 017c 9A68     		ldr	r2, [r3, #8]
 759 017e BB6A     		ldr	r3, [r7, #40]
 760 0180 5B68     		ldr	r3, [r3, #4]
 761 0182 D21A     		subs	r2, r2, r3
 762 0184 BB6A     		ldr	r3, [r7, #40]
 763 0186 9A60     		str	r2, [r3, #8]
 596:../Generated_Code/IntFlashLdd1.c ****         break;
 764              		.loc 1 596 0
 765 0188 B0E0     		b	.L46
 766              	.L43:
 598:../Generated_Code/IntFlashLdd1.c ****         DstAddrOffset = (uint8_t)DeviceDataPrv->CurrentFlashAddress & WRITABLE_UNIT_MASK; /* Comput
 767              		.loc 1 598 0
 768 018a BB6A     		ldr	r3, [r7, #40]
 769 018c 1B69     		ldr	r3, [r3, #16]
 770 018e DBB2     		uxtb	r3, r3
 771 0190 03F00703 		and	r3, r3, #7
 772 0194 87F83630 		strb	r3, [r7, #54]
 599:../Generated_Code/IntFlashLdd1.c ****         MaxPossiblePrgBytes = (WRITABLE_UNIT_MASK - DstAddrOffset) + 1U; /* Compute number of bytes
 773              		.loc 1 599 0
 774 0198 97F83630 		ldrb	r3, [r7, #54]
 775 019c C3F10803 		rsb	r3, r3, #8
 776 01a0 87F82730 		strb	r3, [r7, #39]
 600:../Generated_Code/IntFlashLdd1.c ****         if (DeviceDataPrv->DataCounter < MaxPossiblePrgBytes) {
 777              		.loc 1 600 0
 778 01a4 BB6A     		ldr	r3, [r7, #40]
 779 01a6 9A68     		ldr	r2, [r3, #8]
 780 01a8 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 781 01ac 9A42     		cmp	r2, r3
 782 01ae 04D2     		bcs	.L47
 601:../Generated_Code/IntFlashLdd1.c ****           PrgBytesCount = (uint8_t)DeviceDataPrv->DataCounter;
 783              		.loc 1 601 0
 784 01b0 BB6A     		ldr	r3, [r7, #40]
 785 01b2 9B68     		ldr	r3, [r3, #8]
 786 01b4 87F83730 		strb	r3, [r7, #55]
 787 01b8 03E0     		b	.L48
 788              	.L47:
 603:../Generated_Code/IntFlashLdd1.c ****           PrgBytesCount = MaxPossiblePrgBytes;
 789              		.loc 1 603 0
 790 01ba 97F82730 		ldrb	r3, [r7, #39]
 791 01be 87F83730 		strb	r3, [r7, #55]
 792              	.L48:
 605:../Generated_Code/IntFlashLdd1.c ****         for (i = 0U; i < PrgBytesCount; i++)  {
 793              		.loc 1 605 0
 794 01c2 0023     		movs	r3, #0
 795 01c4 87F83530 		strb	r3, [r7, #53]
 796 01c8 1DE0     		b	.L49
 797              	.L50:
 606:../Generated_Code/IntFlashLdd1.c ****           ((uint8_t *)(void *)&DataToPrg)[DstAddrOffset + i] = ((uint8_t *)(void *)(DeviceDataPrv->
 798              		.loc 1 606 0 discriminator 2
 799 01ca 97F83620 		ldrb	r2, [r7, #54]	@ zero_extendqisi2
 800 01ce 97F83530 		ldrb	r3, [r7, #53]	@ zero_extendqisi2
 801 01d2 1344     		add	r3, r3, r2
 802 01d4 07F11802 		add	r2, r7, #24
 803 01d8 1344     		add	r3, r3, r2
 804 01da BA6A     		ldr	r2, [r7, #40]
 805 01dc D168     		ldr	r1, [r2, #12]
 806 01de 97F83520 		ldrb	r2, [r7, #53]	@ zero_extendqisi2
 807 01e2 0A44     		add	r2, r2, r1
 808 01e4 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 809 01e6 1A70     		strb	r2, [r3]
 607:../Generated_Code/IntFlashLdd1.c ****           ((uint8_t *)(void *)&DataToPrgMask)[DstAddrOffset + i] = 0xFFu;
 810              		.loc 1 607 0 discriminator 2
 811 01e8 97F83620 		ldrb	r2, [r7, #54]	@ zero_extendqisi2
 812 01ec 97F83530 		ldrb	r3, [r7, #53]	@ zero_extendqisi2
 813 01f0 1344     		add	r3, r3, r2
 814 01f2 07F11002 		add	r2, r7, #16
 815 01f6 1344     		add	r3, r3, r2
 816 01f8 FF22     		movs	r2, #255
 817 01fa 1A70     		strb	r2, [r3]
 605:../Generated_Code/IntFlashLdd1.c ****         for (i = 0U; i < PrgBytesCount; i++)  {
 818              		.loc 1 605 0 discriminator 2
 819 01fc 97F83530 		ldrb	r3, [r7, #53]	@ zero_extendqisi2
 820 0200 0133     		adds	r3, r3, #1
 821 0202 87F83530 		strb	r3, [r7, #53]
 822              	.L49:
 605:../Generated_Code/IntFlashLdd1.c ****         for (i = 0U; i < PrgBytesCount; i++)  {
 823              		.loc 1 605 0 is_stmt 0 discriminator 1
 824 0206 97F83520 		ldrb	r2, [r7, #53]	@ zero_extendqisi2
 825 020a 97F83730 		ldrb	r3, [r7, #55]	@ zero_extendqisi2
 826 020e 9A42     		cmp	r2, r3
 827 0210 DBD3     		bcc	.L50
 609:../Generated_Code/IntFlashLdd1.c ****         FlashPrgUnitAddr = DeviceDataPrv->CurrentFlashAddress - DstAddrOffset;
 828              		.loc 1 609 0 is_stmt 1
 829 0212 BB6A     		ldr	r3, [r7, #40]
 830 0214 1A69     		ldr	r2, [r3, #16]
 831 0216 97F83630 		ldrb	r3, [r7, #54]	@ zero_extendqisi2
 832 021a D31A     		subs	r3, r2, r3
 833 021c 3B62     		str	r3, [r7, #32]
 610:../Generated_Code/IntFlashLdd1.c ****         CurrentFlashPrgUnitData[0] = ((uint32_t *)FlashPrgUnitAddr)[0];
 834              		.loc 1 610 0
 835 021e 3B6A     		ldr	r3, [r7, #32]
 836 0220 1B68     		ldr	r3, [r3]
 837 0222 BB60     		str	r3, [r7, #8]
 611:../Generated_Code/IntFlashLdd1.c ****         CurrentFlashPrgUnitData[1] = ((uint32_t *)FlashPrgUnitAddr)[1];
 838              		.loc 1 611 0
 839 0224 3B6A     		ldr	r3, [r7, #32]
 840 0226 0433     		adds	r3, r3, #4
 841 0228 1B68     		ldr	r3, [r3]
 842 022a FB60     		str	r3, [r7, #12]
 612:../Generated_Code/IntFlashLdd1.c ****         if(((DataToPrg[0] & DataToPrgMask[0]) & (~CurrentFlashPrgUnitData[0])) > 0U) {
 843              		.loc 1 612 0
 844 022c BA69     		ldr	r2, [r7, #24]
 845 022e 3B69     		ldr	r3, [r7, #16]
 846 0230 1A40     		ands	r2, r2, r3
 847 0232 BB68     		ldr	r3, [r7, #8]
 848 0234 DB43     		mvns	r3, r3
 849 0236 1340     		ands	r3, r3, r2
 850 0238 002B     		cmp	r3, #0
 851 023a 07D0     		beq	.L51
 613:../Generated_Code/IntFlashLdd1.c ****           DeviceDataPrv->CurrentErrorFlags |= LDD_FLASH_MULTIPLE_WRITE_ERROR;
 852              		.loc 1 613 0
 853 023c BB6A     		ldr	r3, [r7, #40]
 854 023e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 855 0240 43F00403 		orr	r3, r3, #4
 856 0244 DAB2     		uxtb	r2, r3
 857 0246 BB6A     		ldr	r3, [r7, #40]
 858 0248 DA70     		strb	r2, [r3, #3]
 614:../Generated_Code/IntFlashLdd1.c ****           return;
 859              		.loc 1 614 0
 860 024a 96E0     		b	.L23
 861              	.L51:
 616:../Generated_Code/IntFlashLdd1.c ****         if(((DataToPrg[1] & DataToPrgMask[1]) & (~CurrentFlashPrgUnitData[1])) > 0U) {
 862              		.loc 1 616 0
 863 024c FA69     		ldr	r2, [r7, #28]
 864 024e 7B69     		ldr	r3, [r7, #20]
 865 0250 1A40     		ands	r2, r2, r3
 866 0252 FB68     		ldr	r3, [r7, #12]
 867 0254 DB43     		mvns	r3, r3
 868 0256 1340     		ands	r3, r3, r2
 869 0258 002B     		cmp	r3, #0
 870 025a 0BD0     		beq	.L52
 617:../Generated_Code/IntFlashLdd1.c ****           DeviceDataPrv->CurrentErrorFlags |= LDD_FLASH_MULTIPLE_WRITE_ERROR;
 871              		.loc 1 617 0
 872 025c BB6A     		ldr	r3, [r7, #40]
 873 025e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 874 0260 43F00403 		orr	r3, r3, #4
 875 0264 DAB2     		uxtb	r2, r3
 876 0266 BB6A     		ldr	r3, [r7, #40]
 877 0268 DA70     		strb	r2, [r3, #3]
 618:../Generated_Code/IntFlashLdd1.c ****           return;
 878              		.loc 1 618 0
 879 026a 86E0     		b	.L23
 880              	.L59:
 881              		.align	2
 882              	.L58:
 883 026c 00000000 		.word	.LC0
 884 0270 00000240 		.word	1073872896
 885              	.L52:
 620:../Generated_Code/IntFlashLdd1.c ****         DataToPrg[0] = DataToPrg[0] ^ (~CurrentFlashPrgUnitData[0]);
 886              		.loc 1 620 0
 887 0274 BA69     		ldr	r2, [r7, #24]
 888 0276 BB68     		ldr	r3, [r7, #8]
 889 0278 DB43     		mvns	r3, r3
 890 027a 5340     		eors	r3, r3, r2
 891 027c BB61     		str	r3, [r7, #24]
 621:../Generated_Code/IntFlashLdd1.c ****         DataToPrg[1] = DataToPrg[1] ^ (~CurrentFlashPrgUnitData[1]);
 892              		.loc 1 621 0
 893 027e FA69     		ldr	r2, [r7, #28]
 894 0280 FB68     		ldr	r3, [r7, #12]
 895 0282 DB43     		mvns	r3, r3
 896 0284 5340     		eors	r3, r3, r2
 897 0286 FB61     		str	r3, [r7, #28]
 622:../Generated_Code/IntFlashLdd1.c ****         DeviceDataPrv->CurrentDataSize = PrgBytesCount;
 898              		.loc 1 622 0
 899 0288 97F83720 		ldrb	r2, [r7, #55]	@ zero_extendqisi2
 900 028c BB6A     		ldr	r3, [r7, #40]
 901 028e 5A60     		str	r2, [r3, #4]
 623:../Generated_Code/IntFlashLdd1.c ****         DeviceDataPrv->DataCounter -= PrgBytesCount;
 902              		.loc 1 623 0
 903 0290 BB6A     		ldr	r3, [r7, #40]
 904 0292 9A68     		ldr	r2, [r3, #8]
 905 0294 97F83730 		ldrb	r3, [r7, #55]	@ zero_extendqisi2
 906 0298 D21A     		subs	r2, r2, r3
 907 029a BB6A     		ldr	r3, [r7, #40]
 908 029c 9A60     		str	r2, [r3, #8]
 624:../Generated_Code/IntFlashLdd1.c ****         FTFE_PDD_WriteFCCOBFirstLongWordData(FTFE_BASE_PTR, DataToPrg[0]);
 909              		.loc 1 624 0
 910 029e 384B     		ldr	r3, .L60
 911 02a0 BA69     		ldr	r2, [r7, #24]
 912 02a2 120E     		lsrs	r2, r2, #24
 913 02a4 D2B2     		uxtb	r2, r2
 914 02a6 DA72     		strb	r2, [r3, #11]
 915 02a8 354B     		ldr	r3, .L60
 916 02aa BA69     		ldr	r2, [r7, #24]
 917 02ac 120C     		lsrs	r2, r2, #16
 918 02ae D2B2     		uxtb	r2, r2
 919 02b0 9A72     		strb	r2, [r3, #10]
 920 02b2 334B     		ldr	r3, .L60
 921 02b4 BA69     		ldr	r2, [r7, #24]
 922 02b6 120A     		lsrs	r2, r2, #8
 923 02b8 D2B2     		uxtb	r2, r2
 924 02ba 5A72     		strb	r2, [r3, #9]
 925 02bc 304B     		ldr	r3, .L60
 926 02be BA69     		ldr	r2, [r7, #24]
 927 02c0 D2B2     		uxtb	r2, r2
 928 02c2 1A72     		strb	r2, [r3, #8]
 625:../Generated_Code/IntFlashLdd1.c ****         FTFE_PDD_WriteFCCOBSecondLongWordData(FTFE_BASE_PTR, DataToPrg[1]);
 929              		.loc 1 625 0
 930 02c4 2E4B     		ldr	r3, .L60
 931 02c6 FA69     		ldr	r2, [r7, #28]
 932 02c8 120E     		lsrs	r2, r2, #24
 933 02ca D2B2     		uxtb	r2, r2
 934 02cc DA73     		strb	r2, [r3, #15]
 935 02ce 2C4B     		ldr	r3, .L60
 936 02d0 FA69     		ldr	r2, [r7, #28]
 937 02d2 120C     		lsrs	r2, r2, #16
 938 02d4 D2B2     		uxtb	r2, r2
 939 02d6 9A73     		strb	r2, [r3, #14]
 940 02d8 294B     		ldr	r3, .L60
 941 02da FA69     		ldr	r2, [r7, #28]
 942 02dc 120A     		lsrs	r2, r2, #8
 943 02de D2B2     		uxtb	r2, r2
 944 02e0 5A73     		strb	r2, [r3, #13]
 945 02e2 274B     		ldr	r3, .L60
 946 02e4 FA69     		ldr	r2, [r7, #28]
 947 02e6 D2B2     		uxtb	r2, r2
 948 02e8 1A73     		strb	r2, [r3, #12]
 626:../Generated_Code/IntFlashLdd1.c ****         break;
 949              		.loc 1 626 0
 950 02ea 00BF     		nop
 951              	.L46:
 629:../Generated_Code/IntFlashLdd1.c ****     } /* switch(DeviceDataPrv->CurrentOperation) */
 630:../Generated_Code/IntFlashLdd1.c ****     StepsOfBatch -= 1U;
 952              		.loc 1 630 0
 953 02ec 7B8E     		ldrh	r3, [r7, #50]	@ movhi
 954 02ee 013B     		subs	r3, r3, #1
 955 02f0 7B86     		strh	r3, [r7, #50]	@ movhi
 631:../Generated_Code/IntFlashLdd1.c ****     if (DeviceDataPrv->DataCounter == 0U) {
 956              		.loc 1 631 0
 957 02f2 BB6A     		ldr	r3, [r7, #40]
 958 02f4 9B68     		ldr	r3, [r3, #8]
 959 02f6 002B     		cmp	r3, #0
 960 02f8 04D1     		bne	.L53
 632:../Generated_Code/IntFlashLdd1.c ****       NextBatchCycle = FALSE;
 961              		.loc 1 632 0
 962 02fa 0023     		movs	r3, #0
 963 02fc 87F83130 		strb	r3, [r7, #49]
 633:../Generated_Code/IntFlashLdd1.c ****       StepsOfBatch = 0U;
 964              		.loc 1 633 0
 965 0300 0023     		movs	r3, #0
 966 0302 7B86     		strh	r3, [r7, #50]	@ movhi
 967              	.L53:
 634:../Generated_Code/IntFlashLdd1.c ****     }
 635:../Generated_Code/IntFlashLdd1.c ****     if (DeviceDataPrv->CurrentOperation != LDD_FLASH_READ) {
 968              		.loc 1 635 0
 969 0304 BB6A     		ldr	r3, [r7, #40]
 970 0306 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 971 0308 012B     		cmp	r3, #1
 972 030a 2DD0     		beq	.L37
 636:../Generated_Code/IntFlashLdd1.c ****       FTFE_PDD_SetFCCOBCommand(FTFE_BASE_PTR, DeviceDataPrv->CurrentCommand); /* Set the desired fl
 973              		.loc 1 636 0
 974 030c 1C4B     		ldr	r3, .L60
 975 030e BA6A     		ldr	r2, [r7, #40]
 976 0310 9278     		ldrb	r2, [r2, #2]	@ zero_extendqisi2
 977 0312 DA71     		strb	r2, [r3, #7]
 637:../Generated_Code/IntFlashLdd1.c ****       if (DeviceDataPrv->CurrentFlashAddress >= FTFE_FLEXNVM_START_ADDR) {
 978              		.loc 1 637 0
 979 0314 BB6A     		ldr	r3, [r7, #40]
 980 0316 1B69     		ldr	r3, [r3, #16]
 981 0318 B3F1805F 		cmp	r3, #268435456
 982 031c 07D3     		bcc	.L54
 638:../Generated_Code/IntFlashLdd1.c ****         CurrentFlashAddress = (LDD_FLASH_TAddress)((DeviceDataPrv->CurrentFlashAddress ^ FTFE_FLEXN
 983              		.loc 1 638 0
 984 031e BB6A     		ldr	r3, [r7, #40]
 985 0320 1B69     		ldr	r3, [r3, #16]
 986 0322 83F08053 		eor	r3, r3, #268435456
 987 0326 43F40003 		orr	r3, r3, #8388608
 988 032a FB62     		str	r3, [r7, #44]
 989 032c 02E0     		b	.L55
 990              	.L54:
 639:../Generated_Code/IntFlashLdd1.c ****       } else {
 640:../Generated_Code/IntFlashLdd1.c ****         CurrentFlashAddress = DeviceDataPrv->CurrentFlashAddress;
 991              		.loc 1 640 0
 992 032e BB6A     		ldr	r3, [r7, #40]
 993 0330 1B69     		ldr	r3, [r3, #16]
 994 0332 FB62     		str	r3, [r7, #44]
 995              	.L55:
 641:../Generated_Code/IntFlashLdd1.c ****       }
 642:../Generated_Code/IntFlashLdd1.c ****       FTFE_PDD_SetFCCOBAddress(FTFE_BASE_PTR, ((uint32_t)(CurrentFlashAddress - DstAddrOffset))); /
 996              		.loc 1 642 0
 997 0334 124B     		ldr	r3, .L60
 998 0336 FA6A     		ldr	r2, [r7, #44]
 999 0338 D1B2     		uxtb	r1, r2
 1000 033a 97F83620 		ldrb	r2, [r7, #54]
 1001 033e 8A1A     		subs	r2, r1, r2
 1002 0340 D2B2     		uxtb	r2, r2
 1003 0342 1A71     		strb	r2, [r3, #4]
 1004 0344 0E4B     		ldr	r3, .L60
 1005 0346 97F83620 		ldrb	r2, [r7, #54]	@ zero_extendqisi2
 1006 034a F96A     		ldr	r1, [r7, #44]
 1007 034c 8A1A     		subs	r2, r1, r2
 1008 034e 120A     		lsrs	r2, r2, #8
 1009 0350 D2B2     		uxtb	r2, r2
 1010 0352 5A71     		strb	r2, [r3, #5]
 1011 0354 0A4B     		ldr	r3, .L60
 1012 0356 97F83620 		ldrb	r2, [r7, #54]	@ zero_extendqisi2
 1013 035a F96A     		ldr	r1, [r7, #44]
 1014 035c 8A1A     		subs	r2, r1, r2
 1015 035e 120C     		lsrs	r2, r2, #16
 1016 0360 D2B2     		uxtb	r2, r2
 1017 0362 9A71     		strb	r2, [r3, #6]
 643:../Generated_Code/IntFlashLdd1.c ****       SafeRoutineCaller();             /* Call of the safe routine caller - the safe routine's code
 1018              		.loc 1 643 0
 1019 0364 FFF7FEFF 		bl	SafeRoutineCaller
 1020              	.L37:
 574:../Generated_Code/IntFlashLdd1.c ****   while ((StepsOfBatch > 0U) || (NextBatchCycle)) { /* Should another batch of the current operatio
 1021              		.loc 1 574 0 discriminator 1
 1022 0368 7B8E     		ldrh	r3, [r7, #50]
 1023 036a 002B     		cmp	r3, #0
 1024 036c 7FF4C7AE 		bne	.L56
 574:../Generated_Code/IntFlashLdd1.c ****   while ((StepsOfBatch > 0U) || (NextBatchCycle)) { /* Should another batch of the current operatio
 1025              		.loc 1 574 0 is_stmt 0 discriminator 2
 1026 0370 97F83130 		ldrb	r3, [r7, #49]	@ zero_extendqisi2
 1027 0374 002B     		cmp	r3, #0
 1028 0376 7FF4C2AE 		bne	.L56
 1029              	.L23:
 644:../Generated_Code/IntFlashLdd1.c ****     }
 645:../Generated_Code/IntFlashLdd1.c ****   }
 646:../Generated_Code/IntFlashLdd1.c **** }
 1030              		.loc 1 646 0 is_stmt 1
 1031 037a 3837     		adds	r7, r7, #56
 1032 037c BD46     		mov	sp, r7
 1033              		@ sp needed
 1034 037e 80BD     		pop	{r7, pc}
 1035              	.L61:
 1036              		.align	2
 1037              	.L60:
 1038 0380 00000240 		.word	1073872896
 1039              		.cfi_endproc
 1040              	.LFE5:
 1042              		.section	.text.IntFlashLdd1_GetError,"ax",%progbits
 1043              		.align	2
 1044              		.global	IntFlashLdd1_GetError
 1045              		.thumb
 1046              		.thumb_func
 1048              	IntFlashLdd1_GetError:
 1049              	.LFB6:
 647:../Generated_Code/IntFlashLdd1.c **** 
 648:../Generated_Code/IntFlashLdd1.c **** /*
 649:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 650:../Generated_Code/IntFlashLdd1.c **** **     Method      :  IntFlashLdd1_GetError (component FLASH_LDD)
 651:../Generated_Code/IntFlashLdd1.c **** */
 652:../Generated_Code/IntFlashLdd1.c **** /*!
 653:../Generated_Code/IntFlashLdd1.c **** **     @brief
 654:../Generated_Code/IntFlashLdd1.c **** **         Returns an error state of a current (or last) flash
 655:../Generated_Code/IntFlashLdd1.c **** **         operation. 
 656:../Generated_Code/IntFlashLdd1.c **** **     @param
 657:../Generated_Code/IntFlashLdd1.c **** **         DeviceDataPtr   - Device data structure
 658:../Generated_Code/IntFlashLdd1.c **** **                           pointer returned by [Init] method.
 659:../Generated_Code/IntFlashLdd1.c **** **     @param
 660:../Generated_Code/IntFlashLdd1.c **** **         OperationStatus - Pointer to an
 661:../Generated_Code/IntFlashLdd1.c **** **                           output structure with the error status
 662:../Generated_Code/IntFlashLdd1.c **** **                           details. See the LDD_FLASH_TErrorStatus
 663:../Generated_Code/IntFlashLdd1.c **** **                           type's description for details.
 664:../Generated_Code/IntFlashLdd1.c **** */
 665:../Generated_Code/IntFlashLdd1.c **** /* ===================================================================*/
 666:../Generated_Code/IntFlashLdd1.c **** void IntFlashLdd1_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_FLASH_TErrorStatus *OperationStatus)
 667:../Generated_Code/IntFlashLdd1.c **** {
 1050              		.loc 1 667 0
 1051              		.cfi_startproc
 1052              		@ args = 0, pretend = 0, frame = 16
 1053              		@ frame_needed = 1, uses_anonymous_args = 0
 1054              		@ link register save eliminated.
 1055 0000 80B4     		push	{r7}
 1056              		.cfi_def_cfa_offset 4
 1057              		.cfi_offset 7, -4
 1058 0002 85B0     		sub	sp, sp, #20
 1059              		.cfi_def_cfa_offset 24
 1060 0004 00AF     		add	r7, sp, #0
 1061              		.cfi_def_cfa_register 7
 1062 0006 7860     		str	r0, [r7, #4]
 1063 0008 3960     		str	r1, [r7]
 668:../Generated_Code/IntFlashLdd1.c ****   IntFlashLdd1_TDeviceDataPtr DeviceDataPrv = (IntFlashLdd1_TDeviceDataPtr)DeviceDataPtr; /* Auxili
 1064              		.loc 1 668 0
 1065 000a 7B68     		ldr	r3, [r7, #4]
 1066 000c FB60     		str	r3, [r7, #12]
 1067              	.LBB2:
 669:../Generated_Code/IntFlashLdd1.c **** 
 670:../Generated_Code/IntFlashLdd1.c ****   /* copy of information from internal status structure to the output error status structure */
 671:../Generated_Code/IntFlashLdd1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 672:../Generated_Code/IntFlashLdd1.c ****   EnterCritical();
 1068              		.loc 1 672 0
 1069              	@ 672 "../Generated_Code/IntFlashLdd1.c" 1
 1070 000e EFF31380 		MRS R0, FAULTMASK
 1071 0012 71B6     		CPSID f
 1072 0014 F872     		STRB R0, [r7, #11]
 1073              	@ 0 "" 2
 1074              		.thumb
 1075 0016 1C4B     		ldr	r3, .L65
 1076 0018 1B78     		ldrb	r3, [r3]
 1077 001a DBB2     		uxtb	r3, r3
 1078 001c 0133     		adds	r3, r3, #1
 1079 001e DBB2     		uxtb	r3, r3
 1080 0020 194A     		ldr	r2, .L65
 1081 0022 1946     		mov	r1, r3
 1082 0024 1170     		strb	r1, [r2]
 1083 0026 012B     		cmp	r3, #1
 1084 0028 02D1     		bne	.L63
 1085              		.loc 1 672 0 is_stmt 0 discriminator 1
 1086 002a FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 1087 002c 174B     		ldr	r3, .L65+4
 1088 002e 1A70     		strb	r2, [r3]
 1089              	.L63:
 1090              	.LBE2:
 673:../Generated_Code/IntFlashLdd1.c ****   OperationStatus->CurrentOperation = DeviceDataPrv->CurrentOperation; /* Copy the Current operatio
 1091              		.loc 1 673 0 is_stmt 1
 1092 0030 FB68     		ldr	r3, [r7, #12]
 1093 0032 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1094 0034 3B68     		ldr	r3, [r7]
 1095 0036 1A70     		strb	r2, [r3]
 674:../Generated_Code/IntFlashLdd1.c ****   OperationStatus->CurrentCommand = DeviceDataPrv->CurrentCommand; /* Copy the Current command type
 1096              		.loc 1 674 0
 1097 0038 FB68     		ldr	r3, [r7, #12]
 1098 003a 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 1099 003c 3B68     		ldr	r3, [r7]
 1100 003e 5A70     		strb	r2, [r3, #1]
 675:../Generated_Code/IntFlashLdd1.c ****   OperationStatus->CurrentErrorFlags = DeviceDataPrv->CurrentErrorFlags; /* Copy the Current error 
 1101              		.loc 1 675 0
 1102 0040 FB68     		ldr	r3, [r7, #12]
 1103 0042 DA78     		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1104 0044 3B68     		ldr	r3, [r7]
 1105 0046 9A70     		strb	r2, [r3, #2]
 676:../Generated_Code/IntFlashLdd1.c ****   OperationStatus->CurrentAddress = DeviceDataPrv->CurrentFlashAddress; /* Copy the Current flash a
 1106              		.loc 1 676 0
 1107 0048 FB68     		ldr	r3, [r7, #12]
 1108 004a 1A69     		ldr	r2, [r3, #16]
 1109 004c 3B68     		ldr	r3, [r7]
 1110 004e 5A60     		str	r2, [r3, #4]
 677:../Generated_Code/IntFlashLdd1.c ****   OperationStatus->CurrentDataPtr = DeviceDataPrv->CurrentDataPtr; /* Copy the Current input/output
 1111              		.loc 1 677 0
 1112 0050 FB68     		ldr	r3, [r7, #12]
 1113 0052 DA68     		ldr	r2, [r3, #12]
 1114 0054 3B68     		ldr	r3, [r7]
 1115 0056 9A60     		str	r2, [r3, #8]
 678:../Generated_Code/IntFlashLdd1.c ****   OperationStatus->CurrentDataSize = DeviceDataPrv->CurrentDataSize; /* Copy the Current input/outp
 1116              		.loc 1 678 0
 1117 0058 FB68     		ldr	r3, [r7, #12]
 1118 005a 5A68     		ldr	r2, [r3, #4]
 1119 005c 3B68     		ldr	r3, [r7]
 1120 005e DA60     		str	r2, [r3, #12]
 679:../Generated_Code/IntFlashLdd1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 680:../Generated_Code/IntFlashLdd1.c ****   ExitCritical();
 1121              		.loc 1 680 0
 1122 0060 094B     		ldr	r3, .L65
 1123 0062 1B78     		ldrb	r3, [r3]
 1124 0064 DBB2     		uxtb	r3, r3
 1125 0066 013B     		subs	r3, r3, #1
 1126 0068 DBB2     		uxtb	r3, r3
 1127 006a 074A     		ldr	r2, .L65
 1128 006c 1946     		mov	r1, r3
 1129 006e 1170     		strb	r1, [r2]
 1130 0070 002B     		cmp	r3, #0
 1131 0072 03D1     		bne	.L62
 1132              		.loc 1 680 0 is_stmt 0 discriminator 1
 1133 0074 054B     		ldr	r3, .L65+4
 1134              	@ 680 "../Generated_Code/IntFlashLdd1.c" 1
 1135 0076 1878     		ldrb r0, [r3]
 1136 0078 80F31388 		msr FAULTMASK,r0;
 1137              		
 1138              	@ 0 "" 2
 1139              		.thumb
 1140              	.L62:
 681:../Generated_Code/IntFlashLdd1.c **** }
 1141              		.loc 1 681 0 is_stmt 1
 1142 007c 1437     		adds	r7, r7, #20
 1143 007e BD46     		mov	sp, r7
 1144              		@ sp needed
 1145 0080 5DF8047B 		ldr	r7, [sp], #4
 1146 0084 7047     		bx	lr
 1147              	.L66:
 1148 0086 00BF     		.align	2
 1149              	.L65:
 1150 0088 00000000 		.word	SR_lock
 1151 008c 00000000 		.word	SR_reg
 1152              		.cfi_endproc
 1153              	.LFE6:
 1155              		.section	.text.RangeCheck,"ax",%progbits
 1156              		.align	2
 1157              		.thumb
 1158              		.thumb_func
 1160              	RangeCheck:
 1161              	.LFB7:
 682:../Generated_Code/IntFlashLdd1.c **** 
 683:../Generated_Code/IntFlashLdd1.c **** /*
 684:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 685:../Generated_Code/IntFlashLdd1.c **** **     Method      :  RangeCheck (component FLASH_LDD)
 686:../Generated_Code/IntFlashLdd1.c **** **
 687:../Generated_Code/IntFlashLdd1.c **** **     Description :
 688:../Generated_Code/IntFlashLdd1.c **** **         Range check internal routine. This routine is used by the 
 689:../Generated_Code/IntFlashLdd1.c **** **         component's method to test the input address range.
 690:../Generated_Code/IntFlashLdd1.c **** **         This method is internal. It is used by Processor Expert only.
 691:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 692:../Generated_Code/IntFlashLdd1.c **** */
 693:../Generated_Code/IntFlashLdd1.c **** static LDD_TError RangeCheck(LDD_FLASH_TAddress Address, LDD_FLASH_TDataSize Size)
 694:../Generated_Code/IntFlashLdd1.c **** {
 1162              		.loc 1 694 0
 1163              		.cfi_startproc
 1164              		@ args = 0, pretend = 0, frame = 8
 1165              		@ frame_needed = 1, uses_anonymous_args = 0
 1166              		@ link register save eliminated.
 1167 0000 80B4     		push	{r7}
 1168              		.cfi_def_cfa_offset 4
 1169              		.cfi_offset 7, -4
 1170 0002 83B0     		sub	sp, sp, #12
 1171              		.cfi_def_cfa_offset 16
 1172 0004 00AF     		add	r7, sp, #0
 1173              		.cfi_def_cfa_register 7
 1174 0006 7860     		str	r0, [r7, #4]
 1175 0008 3960     		str	r1, [r7]
 695:../Generated_Code/IntFlashLdd1.c ****   if (Size != 0U) {
 1176              		.loc 1 695 0
 1177 000a 3B68     		ldr	r3, [r7]
 1178 000c 002B     		cmp	r3, #0
 1179 000e 25D0     		beq	.L68
 696:../Generated_Code/IntFlashLdd1.c ****     if (Address > IntFlashLdd1_PFLASH_SIZE) {
 1180              		.loc 1 696 0
 1181 0010 7B68     		ldr	r3, [r7, #4]
 1182 0012 B3F5002F 		cmp	r3, #524288
 1183 0016 15D9     		bls	.L69
 697:../Generated_Code/IntFlashLdd1.c ****       if ((Address < IntFlashLdd1_DFLASH_ADDRESS) || \
 1184              		.loc 1 697 0
 1185 0018 7B68     		ldr	r3, [r7, #4]
 1186 001a B3F1805F 		cmp	r3, #268435456
 1187 001e 0FD3     		bcc	.L70
 1188              		.loc 1 697 0 is_stmt 0 discriminator 1
 1189 0020 7A68     		ldr	r2, [r7, #4]
 1190 0022 134B     		ldr	r3, .L74
 1191 0024 9A42     		cmp	r2, r3
 1192 0026 0BD8     		bhi	.L70
 698:../Generated_Code/IntFlashLdd1.c ****          (Address > (IntFlashLdd1_DFLASH_ADDRESS + (IntFlashLdd1_DFLASH_SIZE - 1U))) || \
 1193              		.loc 1 698 0 is_stmt 1
 1194 0028 3B68     		ldr	r3, [r7]
 1195 002a B3F1805F 		cmp	r3, #268435456
 1196 002e 07D8     		bhi	.L70
 699:../Generated_Code/IntFlashLdd1.c ****          (Size > IntFlashLdd1_DFLASH_ADDRESS) || \
 700:../Generated_Code/IntFlashLdd1.c ****          (Address > (IntFlashLdd1_DFLASH_ADDRESS + (IntFlashLdd1_DFLASH_SIZE - Size)))) {
 1197              		.loc 1 700 0
 1198 0030 3B68     		ldr	r3, [r7]
 1199 0032 C3F18053 		rsb	r3, r3, #268435456
 1200 0036 03F50033 		add	r3, r3, #131072
 699:../Generated_Code/IntFlashLdd1.c ****          (Size > IntFlashLdd1_DFLASH_ADDRESS) || \
 1201              		.loc 1 699 0
 1202 003a 7A68     		ldr	r2, [r7, #4]
 1203 003c 9342     		cmp	r3, r2
 1204 003e 0FD2     		bcs	.L71
 1205              	.L70:
 701:../Generated_Code/IntFlashLdd1.c ****         return ERR_PARAM_ADDRESS;
 1206              		.loc 1 701 0
 1207 0040 8923     		movs	r3, #137
 1208 0042 0EE0     		b	.L72
 1209              	.L69:
 702:../Generated_Code/IntFlashLdd1.c ****       }
 703:../Generated_Code/IntFlashLdd1.c ****     } else {
 704:../Generated_Code/IntFlashLdd1.c ****       if ((Size > IntFlashLdd1_PFLASH_SIZE) || (Address > (IntFlashLdd1_PFLASH_SIZE - Size))) {
 1210              		.loc 1 704 0
 1211 0044 3B68     		ldr	r3, [r7]
 1212 0046 B3F5002F 		cmp	r3, #524288
 1213 004a 05D8     		bhi	.L73
 1214              		.loc 1 704 0 is_stmt 0 discriminator 1
 1215 004c 3B68     		ldr	r3, [r7]
 1216 004e C3F50022 		rsb	r2, r3, #524288
 1217 0052 7B68     		ldr	r3, [r7, #4]
 1218 0054 9A42     		cmp	r2, r3
 1219 0056 03D2     		bcs	.L71
 1220              	.L73:
 705:../Generated_Code/IntFlashLdd1.c ****         return ERR_PARAM_ADDRESS;
 1221              		.loc 1 705 0 is_stmt 1
 1222 0058 8923     		movs	r3, #137
 1223 005a 02E0     		b	.L72
 1224              	.L68:
 706:../Generated_Code/IntFlashLdd1.c ****       }
 707:../Generated_Code/IntFlashLdd1.c ****     }
 708:../Generated_Code/IntFlashLdd1.c ****   } else {
 709:../Generated_Code/IntFlashLdd1.c ****     return ERR_PARAM_ADDRESS;
 1225              		.loc 1 709 0
 1226 005c 8923     		movs	r3, #137
 1227 005e 00E0     		b	.L72
 1228              	.L71:
 710:../Generated_Code/IntFlashLdd1.c ****   }
 711:../Generated_Code/IntFlashLdd1.c ****   return ERR_OK;
 1229              		.loc 1 711 0
 1230 0060 0023     		movs	r3, #0
 1231              	.L72:
 712:../Generated_Code/IntFlashLdd1.c **** }
 1232              		.loc 1 712 0
 1233 0062 1846     		mov	r0, r3
 1234 0064 0C37     		adds	r7, r7, #12
 1235 0066 BD46     		mov	sp, r7
 1236              		@ sp needed
 1237 0068 5DF8047B 		ldr	r7, [sp], #4
 1238 006c 7047     		bx	lr
 1239              	.L75:
 1240 006e 00BF     		.align	2
 1241              	.L74:
 1242 0070 FFFF0110 		.word	268566527
 1243              		.cfi_endproc
 1244              	.LFE7:
 1246              		.section	.text.SafeRoutineCaller,"ax",%progbits
 1247              		.align	2
 1248              		.thumb
 1249              		.thumb_func
 1251              	SafeRoutineCaller:
 1252              	.LFB8:
 713:../Generated_Code/IntFlashLdd1.c **** 
 714:../Generated_Code/IntFlashLdd1.c **** /*
 715:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 716:../Generated_Code/IntFlashLdd1.c **** **     Method      :  SafeRoutineCaller (component FLASH_LDD)
 717:../Generated_Code/IntFlashLdd1.c **** **
 718:../Generated_Code/IntFlashLdd1.c **** **     Description :
 719:../Generated_Code/IntFlashLdd1.c **** **         Safe routine caller internal routine. The routine is used to 
 720:../Generated_Code/IntFlashLdd1.c **** **         copy the safe routine code to stack a run it.
 721:../Generated_Code/IntFlashLdd1.c **** **         This method is internal. It is used by Processor Expert only.
 722:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 723:../Generated_Code/IntFlashLdd1.c **** */
 724:../Generated_Code/IntFlashLdd1.c **** static void SafeRoutineCaller(void)
 725:../Generated_Code/IntFlashLdd1.c **** {
 1253              		.loc 1 725 0
 1254              		.cfi_startproc
 1255              		@ args = 0, pretend = 0, frame = 64
 1256              		@ frame_needed = 1, uses_anonymous_args = 0
 1257 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1258              		.cfi_def_cfa_offset 20
 1259              		.cfi_offset 4, -20
 1260              		.cfi_offset 5, -16
 1261              		.cfi_offset 6, -12
 1262              		.cfi_offset 7, -8
 1263              		.cfi_offset 14, -4
 1264 0002 91B0     		sub	sp, sp, #68
 1265              		.cfi_def_cfa_offset 88
 1266 0004 00AF     		add	r7, sp, #0
 1267              		.cfi_def_cfa_register 7
 726:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TSafeRoutineWithPadding SaveRoutineStackSpace;
 727:../Generated_Code/IntFlashLdd1.c ****   LDD_FLASH_TSafeRoutinePtr SafeRoutinePtr;
 728:../Generated_Code/IntFlashLdd1.c **** 
 729:../Generated_Code/IntFlashLdd1.c ****   /* SafeRoutine() code must be placed on 4 bytes aligned address */  
 730:../Generated_Code/IntFlashLdd1.c ****   SafeRoutinePtr = (LDD_FLASH_TSafeRoutinePtr)((((uint32_t)&SaveRoutineStackSpace) + 0x03U) & ~0x03
 1268              		.loc 1 730 0
 1269 0006 07F10803 		add	r3, r7, #8
 1270 000a 0333     		adds	r3, r3, #3
 1271 000c 23F00303 		bic	r3, r3, #3
 1272 0010 FB63     		str	r3, [r7, #60]
 731:../Generated_Code/IntFlashLdd1.c ****   /* Copy the safe routine's code to a buffer on the stack */
 732:../Generated_Code/IntFlashLdd1.c ****   *(LDD_FLASH_TSafeRoutine *)(void *)SafeRoutinePtr = *(LDD_FLASH_TSafeRoutine *)(void *)&SafeRouti
 1273              		.loc 1 732 0
 1274 0012 1D4B     		ldr	r3, .L80
 1275 0014 FA6B     		ldr	r2, [r7, #60]
 1276 0016 1046     		mov	r0, r2
 1277 0018 03F13004 		add	r4, r3, #48
 1278              	.L77:
 1279 001c 0246     		mov	r2, r0
 1280 001e 1946     		mov	r1, r3
 1281 0020 D1F800E0 		ldr	lr, [r1]	@ unaligned
 1282 0024 4E68     		ldr	r6, [r1, #4]	@ unaligned
 1283 0026 8D68     		ldr	r5, [r1, #8]	@ unaligned
 1284 0028 C968     		ldr	r1, [r1, #12]	@ unaligned
 1285 002a C2F800E0 		str	lr, [r2]	@ unaligned
 1286 002e 5660     		str	r6, [r2, #4]	@ unaligned
 1287 0030 9560     		str	r5, [r2, #8]	@ unaligned
 1288 0032 D160     		str	r1, [r2, #12]	@ unaligned
 1289 0034 1033     		adds	r3, r3, #16
 1290 0036 1030     		adds	r0, r0, #16
 1291 0038 A342     		cmp	r3, r4
 1292 003a EFD1     		bne	.L77
 1293              	.LBB3:
 733:../Generated_Code/IntFlashLdd1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 734:../Generated_Code/IntFlashLdd1.c ****   EnterCritical();
 1294              		.loc 1 734 0
 1295              	@ 734 "../Generated_Code/IntFlashLdd1.c" 1
 1296 003c EFF31380 		MRS R0, FAULTMASK
 1297 0040 71B6     		CPSID f
 1298 0042 F871     		STRB R0, [r7, #7]
 1299              	@ 0 "" 2
 1300              		.thumb
 1301 0044 114B     		ldr	r3, .L80+4
 1302 0046 1B78     		ldrb	r3, [r3]
 1303 0048 DBB2     		uxtb	r3, r3
 1304 004a 0133     		adds	r3, r3, #1
 1305 004c DBB2     		uxtb	r3, r3
 1306 004e 0F4A     		ldr	r2, .L80+4
 1307 0050 1946     		mov	r1, r3
 1308 0052 1170     		strb	r1, [r2]
 1309 0054 012B     		cmp	r3, #1
 1310 0056 02D1     		bne	.L78
 1311              		.loc 1 734 0 is_stmt 0 discriminator 1
 1312 0058 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1313 005a 0D4B     		ldr	r3, .L80+8
 1314 005c 1A70     		strb	r2, [r3]
 1315              	.L78:
 1316              	.LBE3:
 735:../Generated_Code/IntFlashLdd1.c ****   ((LDD_FLASH_TSafeRoutinePtr)((uint32_t)(SafeRoutinePtr) | 1U))(); /* Run the Safe routine */
 1317              		.loc 1 735 0 is_stmt 1
 1318 005e FB6B     		ldr	r3, [r7, #60]
 1319 0060 43F00103 		orr	r3, r3, #1
 1320 0064 9847     		blx	r3
 736:../Generated_Code/IntFlashLdd1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 737:../Generated_Code/IntFlashLdd1.c ****   ExitCritical();
 1321              		.loc 1 737 0
 1322 0066 094B     		ldr	r3, .L80+4
 1323 0068 1B78     		ldrb	r3, [r3]
 1324 006a DBB2     		uxtb	r3, r3
 1325 006c 013B     		subs	r3, r3, #1
 1326 006e DBB2     		uxtb	r3, r3
 1327 0070 064A     		ldr	r2, .L80+4
 1328 0072 1946     		mov	r1, r3
 1329 0074 1170     		strb	r1, [r2]
 1330 0076 002B     		cmp	r3, #0
 1331 0078 03D1     		bne	.L76
 1332              		.loc 1 737 0 is_stmt 0 discriminator 1
 1333 007a 054B     		ldr	r3, .L80+8
 1334              	@ 737 "../Generated_Code/IntFlashLdd1.c" 1
 1335 007c 1878     		ldrb r0, [r3]
 1336 007e 80F31388 		msr FAULTMASK,r0;
 1337              		
 1338              	@ 0 "" 2
 1339              		.thumb
 1340              	.L76:
 738:../Generated_Code/IntFlashLdd1.c **** }
 1341              		.loc 1 738 0 is_stmt 1
 1342 0082 4437     		adds	r7, r7, #68
 1343 0084 BD46     		mov	sp, r7
 1344              		@ sp needed
 1345 0086 F0BD     		pop	{r4, r5, r6, r7, pc}
 1346              	.L81:
 1347              		.align	2
 1348              	.L80:
 1349 0088 00000000 		.word	SafeRoutine
 1350 008c 00000000 		.word	SR_lock
 1351 0090 00000000 		.word	SR_reg
 1352              		.cfi_endproc
 1353              	.LFE8:
 1355              		.section	.text.IntFlashLdd1_GetDriverState,"ax",%progbits
 1356              		.align	2
 1357              		.global	IntFlashLdd1_GetDriverState
 1358              		.thumb
 1359              		.thumb_func
 1361              	IntFlashLdd1_GetDriverState:
 1362              	.LFB9:
 739:../Generated_Code/IntFlashLdd1.c **** 
 740:../Generated_Code/IntFlashLdd1.c **** /*
 741:../Generated_Code/IntFlashLdd1.c **** ** ===================================================================
 742:../Generated_Code/IntFlashLdd1.c **** **     Method      :  IntFlashLdd1_GetDriverState (component FLASH_LDD)
 743:../Generated_Code/IntFlashLdd1.c **** */
 744:../Generated_Code/IntFlashLdd1.c **** /*!
 745:../Generated_Code/IntFlashLdd1.c **** **     @brief
 746:../Generated_Code/IntFlashLdd1.c **** **         This method returns the current driver status.
 747:../Generated_Code/IntFlashLdd1.c **** **     @param
 748:../Generated_Code/IntFlashLdd1.c **** **         DeviceDataPtr   - Device data structure
 749:../Generated_Code/IntFlashLdd1.c **** **                           pointer returned by [Init] method.
 750:../Generated_Code/IntFlashLdd1.c **** **     @return
 751:../Generated_Code/IntFlashLdd1.c **** **                         - The current driver status mask.
 752:../Generated_Code/IntFlashLdd1.c **** **                           Following status masks defined in PE_Types.
 753:../Generated_Code/IntFlashLdd1.c **** **                           h can be used to check the current driver
 754:../Generated_Code/IntFlashLdd1.c **** **                           status.
 755:../Generated_Code/IntFlashLdd1.c **** **                           PE_LDD_DRIVER_DISABLED_IN_CLOCK_CONFIGURATIO
 756:../Generated_Code/IntFlashLdd1.c **** **                           N - 1 - Driver is disabled in the current
 757:../Generated_Code/IntFlashLdd1.c **** **                           mode; 0 - Driver is enabled in the current
 758:../Generated_Code/IntFlashLdd1.c **** **                           mode.  
 759:../Generated_Code/IntFlashLdd1.c **** **                           PE_LDD_DRIVER_DISABLED_BY_USER - 1 - Driver
 760:../Generated_Code/IntFlashLdd1.c **** **                           is disabled by the user; 0 - Driver is
 761:../Generated_Code/IntFlashLdd1.c **** **                           enabled by the user.        
 762:../Generated_Code/IntFlashLdd1.c **** **                           PE_LDD_DRIVER_BUSY - 1 - Driver is the BUSY
 763:../Generated_Code/IntFlashLdd1.c **** **                           state; 0 - Driver is in the IDLE state.
 764:../Generated_Code/IntFlashLdd1.c **** */
 765:../Generated_Code/IntFlashLdd1.c **** /* ===================================================================*/
 766:../Generated_Code/IntFlashLdd1.c **** LDD_TDriverState IntFlashLdd1_GetDriverState(LDD_TDeviceData *DeviceDataPtr)
 767:../Generated_Code/IntFlashLdd1.c **** {
 1363              		.loc 1 767 0
 1364              		.cfi_startproc
 1365              		@ args = 0, pretend = 0, frame = 16
 1366              		@ frame_needed = 1, uses_anonymous_args = 0
 1367              		@ link register save eliminated.
 1368 0000 80B4     		push	{r7}
 1369              		.cfi_def_cfa_offset 4
 1370              		.cfi_offset 7, -4
 1371 0002 85B0     		sub	sp, sp, #20
 1372              		.cfi_def_cfa_offset 24
 1373 0004 00AF     		add	r7, sp, #0
 1374              		.cfi_def_cfa_register 7
 1375 0006 7860     		str	r0, [r7, #4]
 768:../Generated_Code/IntFlashLdd1.c ****   IntFlashLdd1_TDeviceData *DeviceDataPrv = (IntFlashLdd1_TDeviceData *)DeviceDataPtr;
 1376              		.loc 1 768 0
 1377 0008 7B68     		ldr	r3, [r7, #4]
 1378 000a FB60     		str	r3, [r7, #12]
 769:../Generated_Code/IntFlashLdd1.c ****   LDD_TDriverState DriverState = 0x00U;
 1379              		.loc 1 769 0
 1380 000c 0023     		movs	r3, #0
 1381 000e 7B81     		strh	r3, [r7, #10]	@ movhi
 770:../Generated_Code/IntFlashLdd1.c **** 
 771:../Generated_Code/IntFlashLdd1.c ****   DriverState |= ((DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_RUNNING) || /* Is driver busy
 1382              		.loc 1 771 0
 1383 0010 FB68     		ldr	r3, [r7, #12]
 1384 0012 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1385 0014 052B     		cmp	r3, #5
 1386 0016 07D0     		beq	.L83
 772:../Generated_Code/IntFlashLdd1.c ****                   (DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_START) || \
 1387              		.loc 1 772 0 discriminator 2
 1388 0018 FB68     		ldr	r3, [r7, #12]
 1389 001a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 771:../Generated_Code/IntFlashLdd1.c ****   DriverState |= ((DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_RUNNING) || /* Is driver busy
 1390              		.loc 1 771 0 discriminator 2
 1391 001c 042B     		cmp	r3, #4
 1392 001e 03D0     		beq	.L83
 773:../Generated_Code/IntFlashLdd1.c ****                   (DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_STOP_REQ))? PE_LDD_DRIVER_BUS
 1393              		.loc 1 773 0
 1394 0020 FB68     		ldr	r3, [r7, #12]
 1395 0022 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 772:../Generated_Code/IntFlashLdd1.c ****                   (DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_START) || \
 1396              		.loc 1 772 0
 1397 0024 032B     		cmp	r3, #3
 1398 0026 01D1     		bne	.L84
 1399              	.L83:
 771:../Generated_Code/IntFlashLdd1.c ****   DriverState |= ((DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_RUNNING) || /* Is driver busy
 1400              		.loc 1 771 0 discriminator 1
 1401 0028 0423     		movs	r3, #4
 1402 002a 00E0     		b	.L85
 1403              	.L84:
 771:../Generated_Code/IntFlashLdd1.c ****   DriverState |= ((DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_RUNNING) || /* Is driver busy
 1404              		.loc 1 771 0 is_stmt 0
 1405 002c 0023     		movs	r3, #0
 1406              	.L85:
 771:../Generated_Code/IntFlashLdd1.c ****   DriverState |= ((DeviceDataPrv->CurrentOperationStatus == LDD_FLASH_RUNNING) || /* Is driver busy
 1407              		.loc 1 771 0 discriminator 3
 1408 002e 7A89     		ldrh	r2, [r7, #10]	@ movhi
 1409 0030 1343     		orrs	r3, r3, r2
 1410 0032 7B81     		strh	r3, [r7, #10]	@ movhi
 774:../Generated_Code/IntFlashLdd1.c ****   return DriverState;
 1411              		.loc 1 774 0 is_stmt 1 discriminator 3
 1412 0034 7B89     		ldrh	r3, [r7, #10]
 775:../Generated_Code/IntFlashLdd1.c **** }
 1413              		.loc 1 775 0 discriminator 3
 1414 0036 1846     		mov	r0, r3
 1415 0038 1437     		adds	r7, r7, #20
 1416 003a BD46     		mov	sp, r7
 1417              		@ sp needed
 1418 003c 5DF8047B 		ldr	r7, [sp], #4
 1419 0040 7047     		bx	lr
 1420              		.cfi_endproc
 1421              	.LFE9:
 1423 0042 00BF     		.text
 1424              	.Letext0:
 1425              		.file 2 "c:\\freescale\\kds_v3\\toolchain\\arm-none-eabi\\include\\machine\\_default_types.h"
 1426              		.file 3 "c:\\freescale\\kds_v3\\toolchain\\arm-none-eabi\\include\\stdint.h"
 1427              		.file 4 "../Generated_Code/PE_Types.h"
 1428              		.file 5 "C:/INTRO_HS18/IntroAronAlex/TEAM_Robot/Static_Code/IO_Map/MK22F12.h"
 1429              		.file 6 "../Generated_Code/Cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 IntFlashLdd1.c
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:21     .rodata.SafeRoutine:00000000 $d
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:24     .rodata.SafeRoutine:00000000 SafeRoutine
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:50     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:53     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:56     .text.IntFlashLdd1_Init:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:61     .text.IntFlashLdd1_Init:00000000 IntFlashLdd1_Init
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:126    .text.IntFlashLdd1_Init:00000058 $d
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:133    .text.IntFlashLdd1_Write:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:138    .text.IntFlashLdd1_Write:00000000 IntFlashLdd1_Write
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1160   .text.RangeCheck:00000000 RangeCheck
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:232    .text.IntFlashLdd1_Read:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:237    .text.IntFlashLdd1_Read:00000000 IntFlashLdd1_Read
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:327    .text.IntFlashLdd1_Erase:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:332    .text.IntFlashLdd1_Erase:00000000 IntFlashLdd1_Erase
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:456    .text.IntFlashLdd1_GetOperationStatus:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:461    .text.IntFlashLdd1_GetOperationStatus:00000000 IntFlashLdd1_GetOperationStatus
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:490    .rodata:00000000 $d
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:495    .text.IntFlashLdd1_Main:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:500    .text.IntFlashLdd1_Main:00000000 IntFlashLdd1_Main
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:883    .text.IntFlashLdd1_Main:0000026c $d
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:887    .text.IntFlashLdd1_Main:00000274 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1251   .text.SafeRoutineCaller:00000000 SafeRoutineCaller
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1038   .text.IntFlashLdd1_Main:00000380 $d
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1043   .text.IntFlashLdd1_GetError:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1048   .text.IntFlashLdd1_GetError:00000000 IntFlashLdd1_GetError
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1150   .text.IntFlashLdd1_GetError:00000088 $d
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1156   .text.RangeCheck:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1242   .text.RangeCheck:00000070 $d
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1247   .text.SafeRoutineCaller:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1349   .text.SafeRoutineCaller:00000088 $d
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1356   .text.IntFlashLdd1_GetDriverState:00000000 $t
C:\Users\Aron\AppData\Local\Temp\ccQxYeML.s:1361   .text.IntFlashLdd1_GetDriverState:00000000 IntFlashLdd1_GetDriverState
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.22dcf9ce9babd46e5ea858ea4400d115
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4._default_types.h.15.8b2cb27e528498f8ff711db085d6e489
                           .group:00000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:00000000 wm4.PE_Types.h.68.de7a315b6e4c635a9a7a45ae6ec20b08
                           .group:00000000 wm4.PE_Error.h.60.6ccf96637e85421388d147a5dcbc3621
                           .group:00000000 wm4.PE_Const.h.60.44eca2ca2a72148441f11b3e43b344a9
                           .group:00000000 wm4.MK22F12.h.59.83dcc0895f45d7d67f2182a38aa7f04f
                           .group:00000000 wm4.PDD_Types.h.5.e0b4125fe5201c5e1f688b067f4f0d54
                           .group:00000000 wm4.FTFE_PDD.h.51.eb57e3c46f91013d6db57cd5bceae4af
                           .group:00000000 wm4.FMC_PDD.h.9.181464bd332af8d36f15c072c1936de8
                           .group:00000000 wm4.Cpu.h.66.9574a96471c5a4e92ddf5418cbdcf9a5
                           .group:00000000 wm4.IntFlashLdd1.h.119.6ef6fcca95541f24b629003abfa3038e
                           .group:00000000 wm4.IFsh1.h.121.c87d7033c18812659e3ae9b3118ceeb7

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
IntFlashLdd1_OnError
IntFlashLdd1_OnOperationComplete
SR_lock
SR_reg
